// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: acmain/assetmgmt/v1/asset.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Asset defines the Asset message.
type Asset struct {
	// asset_id is the unique identifier for this asset within the system.
	// Immutable after creation.
	AssetId string `protobuf:"bytes,1,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// asset_type specifies the type of physical asset (door, gate, barrier, etc).
	AssetType AssetType `protobuf:"varint,2,opt,name=asset_type,json=assetType,proto3,enum=acmain.assetmgmt.v1.AssetType" json:"asset_type,omitempty"`
	// name is a human-readable name for the asset.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// description is an optional human-readable description of the asset.
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// location contains the immutable location binding for this asset.
	// Assets are location-scoped: an asset from Building A cannot be used
	// to grant access in Building B. This is enforced at network and app level.
	Location LocationInfo `protobuf:"bytes,5,opt,name=location,proto3" json:"location"`
	// controller_address is the Cosmos address of the entity that controls
	// this asset. Only the controller can update asset state and modify ACLs.
	// Typically the organization/facility manager.
	ControllerAddress string `protobuf:"bytes,6,opt,name=controller_address,json=controllerAddress,proto3" json:"controller_address,omitempty"`
	// state is the current operational state of the asset.
	// Updated via MsgUpdateAssetState transactions.
	State AssetState `protobuf:"varint,7,opt,name=state,proto3,enum=acmain.assetmgmt.v1.AssetState" json:"state,omitempty"`
	// metadata is optional key-value data for asset-specific attributes.
	// Examples: model_number, serial_number, manufacturer, firmware_version, etc.
	// Maps are used to support arbitrary metadata without schema changes.
	Metadata map[string]string `protobuf:"bytes,8,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// created_at is the block timestamp when this asset was created.
	// Immutable after creation.
	CreatedAt time.Time `protobuf:"bytes,9,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
	// updated_at is the block timestamp of the most recent state update.
	// Updated whenever asset state changes or metadata is modified.
	UpdatedAt time.Time `protobuf:"bytes,10,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at"`
}

func (m *Asset) Reset()         { *m = Asset{} }
func (m *Asset) String() string { return proto.CompactTextString(m) }
func (*Asset) ProtoMessage()    {}
func (*Asset) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2f084e4f6f29b7a, []int{0}
}
func (m *Asset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Asset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Asset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Asset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Asset.Merge(m, src)
}
func (m *Asset) XXX_Size() int {
	return m.Size()
}
func (m *Asset) XXX_DiscardUnknown() {
	xxx_messageInfo_Asset.DiscardUnknown(m)
}

var xxx_messageInfo_Asset proto.InternalMessageInfo

func (m *Asset) GetAssetId() string {
	if m != nil {
		return m.AssetId
	}
	return ""
}

func (m *Asset) GetAssetType() AssetType {
	if m != nil {
		return m.AssetType
	}
	return ASSET_TYPE_UNSPECIFIED
}

func (m *Asset) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Asset) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Asset) GetLocation() LocationInfo {
	if m != nil {
		return m.Location
	}
	return LocationInfo{}
}

func (m *Asset) GetControllerAddress() string {
	if m != nil {
		return m.ControllerAddress
	}
	return ""
}

func (m *Asset) GetState() AssetState {
	if m != nil {
		return m.State
	}
	return ASSET_STATE_UNSPECIFIED
}

func (m *Asset) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Asset) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *Asset) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

func init() {
	proto.RegisterType((*Asset)(nil), "acmain.assetmgmt.v1.Asset")
	proto.RegisterMapType((map[string]string)(nil), "acmain.assetmgmt.v1.Asset.MetadataEntry")
}

func init() { proto.RegisterFile("acmain/assetmgmt/v1/asset.proto", fileDescriptor_f2f084e4f6f29b7a) }

var fileDescriptor_f2f084e4f6f29b7a = []byte{
	// 525 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0x31, 0x6f, 0xd3, 0x40,
	0x14, 0xce, 0x35, 0x4d, 0x1b, 0x5f, 0x54, 0x44, 0x8f, 0x0c, 0xd7, 0x0c, 0x76, 0xca, 0x42, 0x54,
	0x09, 0x5b, 0x0d, 0x42, 0x42, 0x45, 0x0c, 0x89, 0x40, 0xb4, 0x12, 0x2c, 0x6e, 0x27, 0x96, 0xe8,
	0x6a, 0x5f, 0x2c, 0x0b, 0xdf, 0x9d, 0xe5, 0xbb, 0x44, 0xe4, 0x2f, 0x30, 0x75, 0x67, 0x61, 0x64,
	0xec, 0xc0, 0x8f, 0xe8, 0x58, 0x31, 0x31, 0x01, 0x4a, 0x86, 0xf2, 0x33, 0x90, 0xef, 0xce, 0xa1,
	0x48, 0xee, 0xc0, 0x62, 0xbd, 0xef, 0xbd, 0xef, 0x7b, 0xbe, 0xfb, 0xde, 0x3b, 0xe8, 0x91, 0x88,
	0x91, 0x94, 0x07, 0x44, 0x4a, 0xaa, 0x58, 0xc2, 0x54, 0x30, 0x3f, 0x34, 0xc0, 0xcf, 0x0b, 0xa1,
	0x04, 0x7a, 0x60, 0x08, 0xfe, 0x9a, 0xe0, 0xcf, 0x0f, 0x7b, 0xb5, 0x2a, 0xca, 0x67, 0x4c, 0x1a,
	0x55, 0xef, 0x51, 0x1d, 0x21, 0x13, 0x11, 0x51, 0xa9, 0xe0, 0x93, 0x94, 0x4f, 0x85, 0x25, 0xee,
	0x12, 0x96, 0x72, 0x11, 0xe8, 0xaf, 0x4d, 0xed, 0x45, 0x42, 0x32, 0x21, 0x27, 0x1a, 0x05, 0x06,
	0xd8, 0x52, 0x37, 0x11, 0x89, 0x30, 0xf9, 0x32, 0xb2, 0x59, 0x2f, 0x11, 0x22, 0xc9, 0x68, 0xa0,
	0xd1, 0xf9, 0x6c, 0x1a, 0xa8, 0x94, 0x51, 0xa9, 0x08, 0xcb, 0x0d, 0xe1, 0xe1, 0xa7, 0x16, 0x6c,
	0x8d, 0xca, 0x93, 0xa0, 0x3d, 0xd8, 0xd6, 0x47, 0x9a, 0xa4, 0x31, 0x06, 0x7d, 0x30, 0x70, 0xc2,
	0x6d, 0x8d, 0x4f, 0x62, 0xf4, 0x02, 0x42, 0x53, 0x52, 0x8b, 0x9c, 0xe2, 0x8d, 0x3e, 0x18, 0xdc,
	0x1b, 0xba, 0x7e, 0xcd, 0xed, 0x7d, 0xdd, 0xea, 0x6c, 0x91, 0xd3, 0xd0, 0x21, 0x55, 0x88, 0x10,
	0xdc, 0xe4, 0x84, 0x51, 0xdc, 0xd4, 0x5d, 0x75, 0x8c, 0xfa, 0xb0, 0x13, 0x53, 0x19, 0x15, 0x69,
	0x5e, 0x5e, 0x1b, 0x6f, 0xea, 0xd2, 0xed, 0x14, 0x3a, 0x86, 0xed, 0xca, 0x15, 0xdc, 0xea, 0x83,
	0x41, 0x67, 0xb8, 0x5f, 0xfb, 0xcb, 0x37, 0x96, 0x74, 0xc2, 0xa7, 0x62, 0xec, 0x5c, 0xfd, 0xf0,
	0x1a, 0x5f, 0x6e, 0x2e, 0x0f, 0x40, 0xb8, 0x56, 0xa3, 0xd7, 0x10, 0x45, 0x82, 0xab, 0x42, 0x64,
	0x19, 0x2d, 0x26, 0x24, 0x8e, 0x0b, 0x2a, 0x25, 0xde, 0x2a, 0x7f, 0x39, 0xc6, 0xdf, 0xbe, 0x3e,
	0xee, 0x5a, 0x23, 0x47, 0xa6, 0x72, 0xaa, 0x8a, 0x94, 0x27, 0xe1, 0xee, 0x5f, 0x8d, 0x2d, 0xa0,
	0xa7, 0xb0, 0x25, 0x15, 0x51, 0x14, 0x6f, 0x6b, 0x0b, 0xbc, 0xbb, 0x2d, 0x38, 0x2d, 0x69, 0xa1,
	0x61, 0xa3, 0x97, 0xb0, 0xcd, 0xa8, 0x22, 0x31, 0x51, 0x04, 0xb7, 0xfb, 0xcd, 0x41, 0x67, 0x38,
	0xb8, 0x5b, 0xe9, 0xbf, 0xb5, 0xd4, 0x57, 0x5c, 0x15, 0x8b, 0x70, 0xad, 0x44, 0xc7, 0x10, 0x46,
	0x05, 0x25, 0x8a, 0xc6, 0x13, 0xa2, 0xb0, 0xa3, 0x1d, 0xe9, 0xf9, 0x66, 0xbe, 0x7e, 0x35, 0x5f,
	0xff, 0xac, 0x9a, 0xef, 0x78, 0xa7, 0xb4, 0xe2, 0xe2, 0xa7, 0x07, 0x8c, 0x1d, 0x8e, 0x15, 0x8f,
	0x54, 0xd9, 0x69, 0x96, 0xc7, 0x55, 0x27, 0xf8, 0xdf, 0x9d, 0xac, 0x78, 0xa4, 0x7a, 0xcf, 0xe1,
	0xce, 0x3f, 0xc7, 0x45, 0xf7, 0x61, 0xf3, 0x3d, 0x5d, 0xd8, 0xfd, 0x29, 0x43, 0xd4, 0x85, 0xad,
	0x39, 0xc9, 0x66, 0x66, 0x6d, 0x9c, 0xd0, 0x80, 0xa3, 0x8d, 0x67, 0xe0, 0x68, 0xff, 0xf7, 0x67,
	0x0f, 0x7c, 0xbc, 0xb9, 0x3c, 0xc0, 0xf6, 0x45, 0x7c, 0xb8, 0xf5, 0x26, 0xb4, 0x17, 0xe3, 0xe1,
	0xd5, 0xd2, 0x05, 0xd7, 0x4b, 0x17, 0xfc, 0x5a, 0xba, 0xe0, 0x62, 0xe5, 0x36, 0xae, 0x57, 0x6e,
	0xe3, 0xfb, 0xca, 0x6d, 0xbc, 0xab, 0xd3, 0x94, 0xdb, 0x29, 0xcf, 0xb7, 0xf4, 0x0d, 0x9e, 0xfc,
	0x09, 0x00, 0x00, 0xff, 0xff, 0x4a, 0x79, 0x95, 0x0b, 0xbf, 0x03, 0x00, 0x00,
}

func (this *Asset) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Asset)
	if !ok {
		that2, ok := that.(Asset)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AssetId != that1.AssetId {
		return false
	}
	if this.AssetType != that1.AssetType {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !this.Location.Equal(&that1.Location) {
		return false
	}
	if this.ControllerAddress != that1.ControllerAddress {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if len(this.Metadata) != len(that1.Metadata) {
		return false
	}
	for i := range this.Metadata {
		if this.Metadata[i] != that1.Metadata[i] {
			return false
		}
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	return true
}
func (m *Asset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Asset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Asset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintAsset(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x52
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintAsset(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x4a
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAsset(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAsset(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAsset(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.State != 0 {
		i = encodeVarintAsset(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x38
	}
	if len(m.ControllerAddress) > 0 {
		i -= len(m.ControllerAddress)
		copy(dAtA[i:], m.ControllerAddress)
		i = encodeVarintAsset(dAtA, i, uint64(len(m.ControllerAddress)))
		i--
		dAtA[i] = 0x32
	}
	{
		size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAsset(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAsset(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAsset(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AssetType != 0 {
		i = encodeVarintAsset(dAtA, i, uint64(m.AssetType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AssetId) > 0 {
		i -= len(m.AssetId)
		copy(dAtA[i:], m.AssetId)
		i = encodeVarintAsset(dAtA, i, uint64(len(m.AssetId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAsset(dAtA []byte, offset int, v uint64) int {
	offset -= sovAsset(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Asset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AssetId)
	if l > 0 {
		n += 1 + l + sovAsset(uint64(l))
	}
	if m.AssetType != 0 {
		n += 1 + sovAsset(uint64(m.AssetType))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAsset(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAsset(uint64(l))
	}
	l = m.Location.Size()
	n += 1 + l + sovAsset(uint64(l))
	l = len(m.ControllerAddress)
	if l > 0 {
		n += 1 + l + sovAsset(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovAsset(uint64(m.State))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAsset(uint64(len(k))) + 1 + len(v) + sovAsset(uint64(len(v)))
			n += mapEntrySize + 1 + sovAsset(uint64(mapEntrySize))
		}
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovAsset(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovAsset(uint64(l))
	return n
}

func sovAsset(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAsset(x uint64) (n int) {
	return sovAsset(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Asset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Asset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Asset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetType", wireType)
			}
			m.AssetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssetType |= AssetType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsset
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControllerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControllerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= AssetState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsset
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAsset
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAsset
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAsset
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAsset
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAsset
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAsset
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAsset
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAsset(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAsset
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsset
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsset
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAsset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAsset(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAsset
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAsset
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAsset
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAsset
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAsset        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAsset          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAsset = fmt.Errorf("proto: unexpected end of group")
)
