// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: acmain/assetmgmt/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgUpdateParams is the Msg/UpdateParams request type.
type MsgUpdateParams struct {
	// authority is the address that controls the module (defaults to x/gov unless overwritten).
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// params defines the module parameters to update.
	//
	// NOTE: All parameters must be supplied.
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_54b527611b74f6ce, []int{0}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateParams) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// MsgUpdateParamsResponse defines the response structure for executing a
// MsgUpdateParams message.
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_54b527611b74f6ce, []int{1}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

// MsgCreateAsset is the Msg/CreateAsset request type.
type MsgCreateAsset struct {
	// creator is the address of the entity creating the asset
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// asset_id is the unique identifier for this asset
	AssetId string `protobuf:"bytes,2,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// asset_type specifies the type of physical asset
	AssetType AssetType `protobuf:"varint,3,opt,name=asset_type,json=assetType,proto3,enum=acmain.assetmgmt.v1.AssetType" json:"asset_type,omitempty"`
	// name is a human-readable name for the asset
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// description is an optional description of the asset
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// location contains the location binding for this asset
	Location LocationInfo `protobuf:"bytes,6,opt,name=location,proto3" json:"location"`
	// controller_address is the address that controls this asset
	ControllerAddress string `protobuf:"bytes,7,opt,name=controller_address,json=controllerAddress,proto3" json:"controller_address,omitempty"`
	// metadata is optional key-value data for asset-specific attributes
	Metadata map[string]string `protobuf:"bytes,8,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *MsgCreateAsset) Reset()         { *m = MsgCreateAsset{} }
func (m *MsgCreateAsset) String() string { return proto.CompactTextString(m) }
func (*MsgCreateAsset) ProtoMessage()    {}
func (*MsgCreateAsset) Descriptor() ([]byte, []int) {
	return fileDescriptor_54b527611b74f6ce, []int{2}
}
func (m *MsgCreateAsset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateAsset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateAsset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateAsset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateAsset.Merge(m, src)
}
func (m *MsgCreateAsset) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateAsset) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateAsset.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateAsset proto.InternalMessageInfo

func (m *MsgCreateAsset) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateAsset) GetAssetId() string {
	if m != nil {
		return m.AssetId
	}
	return ""
}

func (m *MsgCreateAsset) GetAssetType() AssetType {
	if m != nil {
		return m.AssetType
	}
	return ASSET_TYPE_UNSPECIFIED
}

func (m *MsgCreateAsset) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreateAsset) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgCreateAsset) GetLocation() LocationInfo {
	if m != nil {
		return m.Location
	}
	return LocationInfo{}
}

func (m *MsgCreateAsset) GetControllerAddress() string {
	if m != nil {
		return m.ControllerAddress
	}
	return ""
}

func (m *MsgCreateAsset) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// MsgCreateAssetResponse is the Msg/CreateAsset response type.
type MsgCreateAssetResponse struct {
	// asset is the created asset
	Asset Asset `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset"`
}

func (m *MsgCreateAssetResponse) Reset()         { *m = MsgCreateAssetResponse{} }
func (m *MsgCreateAssetResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateAssetResponse) ProtoMessage()    {}
func (*MsgCreateAssetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_54b527611b74f6ce, []int{3}
}
func (m *MsgCreateAssetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateAssetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateAssetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateAssetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateAssetResponse.Merge(m, src)
}
func (m *MsgCreateAssetResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateAssetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateAssetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateAssetResponse proto.InternalMessageInfo

func (m *MsgCreateAssetResponse) GetAsset() Asset {
	if m != nil {
		return m.Asset
	}
	return Asset{}
}

// MsgUpdateAssetState is the Msg/UpdateAssetState request type.
type MsgUpdateAssetState struct {
	// controller is the address of the asset controller
	Controller string `protobuf:"bytes,1,opt,name=controller,proto3" json:"controller,omitempty"`
	// asset_id is the ID of the asset to update
	AssetId string `protobuf:"bytes,2,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// new_state is the new operational state
	NewState AssetState `protobuf:"varint,3,opt,name=new_state,json=newState,proto3,enum=acmain.assetmgmt.v1.AssetState" json:"new_state,omitempty"`
}

func (m *MsgUpdateAssetState) Reset()         { *m = MsgUpdateAssetState{} }
func (m *MsgUpdateAssetState) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateAssetState) ProtoMessage()    {}
func (*MsgUpdateAssetState) Descriptor() ([]byte, []int) {
	return fileDescriptor_54b527611b74f6ce, []int{4}
}
func (m *MsgUpdateAssetState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateAssetState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateAssetState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateAssetState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateAssetState.Merge(m, src)
}
func (m *MsgUpdateAssetState) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateAssetState) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateAssetState.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateAssetState proto.InternalMessageInfo

func (m *MsgUpdateAssetState) GetController() string {
	if m != nil {
		return m.Controller
	}
	return ""
}

func (m *MsgUpdateAssetState) GetAssetId() string {
	if m != nil {
		return m.AssetId
	}
	return ""
}

func (m *MsgUpdateAssetState) GetNewState() AssetState {
	if m != nil {
		return m.NewState
	}
	return ASSET_STATE_UNSPECIFIED
}

// MsgUpdateAssetStateResponse is the Msg/UpdateAssetState response type.
type MsgUpdateAssetStateResponse struct {
}

func (m *MsgUpdateAssetStateResponse) Reset()         { *m = MsgUpdateAssetStateResponse{} }
func (m *MsgUpdateAssetStateResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateAssetStateResponse) ProtoMessage()    {}
func (*MsgUpdateAssetStateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_54b527611b74f6ce, []int{5}
}
func (m *MsgUpdateAssetStateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateAssetStateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateAssetStateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateAssetStateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateAssetStateResponse.Merge(m, src)
}
func (m *MsgUpdateAssetStateResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateAssetStateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateAssetStateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateAssetStateResponse proto.InternalMessageInfo

// MsgUpdateAssetMetadata is the Msg/UpdateAssetMetadata request type.
type MsgUpdateAssetMetadata struct {
	// controller is the address of the asset controller
	Controller string `protobuf:"bytes,1,opt,name=controller,proto3" json:"controller,omitempty"`
	// asset_id is the ID of the asset to update
	AssetId string `protobuf:"bytes,2,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// metadata is the new metadata to set (replaces existing)
	Metadata map[string]string `protobuf:"bytes,3,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *MsgUpdateAssetMetadata) Reset()         { *m = MsgUpdateAssetMetadata{} }
func (m *MsgUpdateAssetMetadata) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateAssetMetadata) ProtoMessage()    {}
func (*MsgUpdateAssetMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_54b527611b74f6ce, []int{6}
}
func (m *MsgUpdateAssetMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateAssetMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateAssetMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateAssetMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateAssetMetadata.Merge(m, src)
}
func (m *MsgUpdateAssetMetadata) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateAssetMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateAssetMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateAssetMetadata proto.InternalMessageInfo

func (m *MsgUpdateAssetMetadata) GetController() string {
	if m != nil {
		return m.Controller
	}
	return ""
}

func (m *MsgUpdateAssetMetadata) GetAssetId() string {
	if m != nil {
		return m.AssetId
	}
	return ""
}

func (m *MsgUpdateAssetMetadata) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// MsgUpdateAssetMetadataResponse is the Msg/UpdateAssetMetadata response type.
type MsgUpdateAssetMetadataResponse struct {
}

func (m *MsgUpdateAssetMetadataResponse) Reset()         { *m = MsgUpdateAssetMetadataResponse{} }
func (m *MsgUpdateAssetMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateAssetMetadataResponse) ProtoMessage()    {}
func (*MsgUpdateAssetMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_54b527611b74f6ce, []int{7}
}
func (m *MsgUpdateAssetMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateAssetMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateAssetMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateAssetMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateAssetMetadataResponse.Merge(m, src)
}
func (m *MsgUpdateAssetMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateAssetMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateAssetMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateAssetMetadataResponse proto.InternalMessageInfo

// MsgTransferAssetController is the Msg/TransferAssetController request type.
type MsgTransferAssetController struct {
	// current_controller is the address of the current controller
	CurrentController string `protobuf:"bytes,1,opt,name=current_controller,json=currentController,proto3" json:"current_controller,omitempty"`
	// asset_id is the ID of the asset to transfer
	AssetId string `protobuf:"bytes,2,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// new_controller is the address of the new controller
	NewController string `protobuf:"bytes,3,opt,name=new_controller,json=newController,proto3" json:"new_controller,omitempty"`
}

func (m *MsgTransferAssetController) Reset()         { *m = MsgTransferAssetController{} }
func (m *MsgTransferAssetController) String() string { return proto.CompactTextString(m) }
func (*MsgTransferAssetController) ProtoMessage()    {}
func (*MsgTransferAssetController) Descriptor() ([]byte, []int) {
	return fileDescriptor_54b527611b74f6ce, []int{8}
}
func (m *MsgTransferAssetController) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferAssetController) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferAssetController.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferAssetController) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferAssetController.Merge(m, src)
}
func (m *MsgTransferAssetController) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferAssetController) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferAssetController.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferAssetController proto.InternalMessageInfo

func (m *MsgTransferAssetController) GetCurrentController() string {
	if m != nil {
		return m.CurrentController
	}
	return ""
}

func (m *MsgTransferAssetController) GetAssetId() string {
	if m != nil {
		return m.AssetId
	}
	return ""
}

func (m *MsgTransferAssetController) GetNewController() string {
	if m != nil {
		return m.NewController
	}
	return ""
}

// MsgTransferAssetControllerResponse is the Msg/TransferAssetController response type.
type MsgTransferAssetControllerResponse struct {
}

func (m *MsgTransferAssetControllerResponse) Reset()         { *m = MsgTransferAssetControllerResponse{} }
func (m *MsgTransferAssetControllerResponse) String() string { return proto.CompactTextString(m) }
func (*MsgTransferAssetControllerResponse) ProtoMessage()    {}
func (*MsgTransferAssetControllerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_54b527611b74f6ce, []int{9}
}
func (m *MsgTransferAssetControllerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferAssetControllerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferAssetControllerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferAssetControllerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferAssetControllerResponse.Merge(m, src)
}
func (m *MsgTransferAssetControllerResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferAssetControllerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferAssetControllerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferAssetControllerResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgUpdateParams)(nil), "acmain.assetmgmt.v1.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "acmain.assetmgmt.v1.MsgUpdateParamsResponse")
	proto.RegisterType((*MsgCreateAsset)(nil), "acmain.assetmgmt.v1.MsgCreateAsset")
	proto.RegisterMapType((map[string]string)(nil), "acmain.assetmgmt.v1.MsgCreateAsset.MetadataEntry")
	proto.RegisterType((*MsgCreateAssetResponse)(nil), "acmain.assetmgmt.v1.MsgCreateAssetResponse")
	proto.RegisterType((*MsgUpdateAssetState)(nil), "acmain.assetmgmt.v1.MsgUpdateAssetState")
	proto.RegisterType((*MsgUpdateAssetStateResponse)(nil), "acmain.assetmgmt.v1.MsgUpdateAssetStateResponse")
	proto.RegisterType((*MsgUpdateAssetMetadata)(nil), "acmain.assetmgmt.v1.MsgUpdateAssetMetadata")
	proto.RegisterMapType((map[string]string)(nil), "acmain.assetmgmt.v1.MsgUpdateAssetMetadata.MetadataEntry")
	proto.RegisterType((*MsgUpdateAssetMetadataResponse)(nil), "acmain.assetmgmt.v1.MsgUpdateAssetMetadataResponse")
	proto.RegisterType((*MsgTransferAssetController)(nil), "acmain.assetmgmt.v1.MsgTransferAssetController")
	proto.RegisterType((*MsgTransferAssetControllerResponse)(nil), "acmain.assetmgmt.v1.MsgTransferAssetControllerResponse")
}

func init() { proto.RegisterFile("acmain/assetmgmt/v1/tx.proto", fileDescriptor_54b527611b74f6ce) }

var fileDescriptor_54b527611b74f6ce = []byte{
	// 874 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x4d, 0x6f, 0x1b, 0x45,
	0x18, 0xce, 0xc6, 0xf9, 0xb0, 0x5f, 0xd3, 0xd0, 0x4c, 0x22, 0xb2, 0xd9, 0xc2, 0xc6, 0x5d, 0x2a,
	0x30, 0x29, 0xb5, 0xc9, 0x56, 0x40, 0x71, 0x29, 0xa8, 0x89, 0x10, 0x44, 0xc2, 0x12, 0xda, 0x36,
	0x17, 0x2e, 0xd6, 0xd4, 0x9e, 0x2c, 0x2b, 0xb2, 0x33, 0xd6, 0xce, 0x24, 0xae, 0x6f, 0x08, 0x6e,
	0x88, 0x03, 0xff, 0x02, 0x8e, 0x39, 0xf0, 0x03, 0x72, 0xec, 0xb1, 0xe2, 0xc4, 0x09, 0xa1, 0x04,
	0x29, 0x7f, 0x03, 0xcd, 0xec, 0x87, 0xd7, 0x65, 0x36, 0xb6, 0x0f, 0xb9, 0x58, 0xf3, 0xbe, 0xef,
	0xf3, 0x7e, 0xcc, 0x33, 0xcf, 0x8c, 0x17, 0xde, 0xc4, 0xdd, 0x10, 0x07, 0xb4, 0x89, 0x39, 0x27,
	0x22, 0xf4, 0x43, 0xd1, 0x3c, 0xd9, 0x69, 0x8a, 0xe7, 0x8d, 0x7e, 0xc4, 0x04, 0x43, 0x6b, 0x71,
	0xb4, 0x91, 0x45, 0x1b, 0x27, 0x3b, 0xd6, 0x96, 0x2e, 0x45, 0x19, 0x71, 0x96, 0x1e, 0x40, 0xe8,
	0x71, 0xc8, 0x13, 0xc0, 0xbb, 0x3a, 0xc0, 0x11, 0xeb, 0x62, 0x11, 0x30, 0xda, 0x09, 0xe8, 0x21,
	0x4b, 0x80, 0x35, 0x1d, 0xb0, 0x8f, 0x23, 0x9c, 0x95, 0x5a, 0xc5, 0x61, 0x40, 0x59, 0x53, 0xfd,
	0x26, 0xae, 0x8d, 0x2e, 0xe3, 0x21, 0xe3, 0xcd, 0x90, 0xfb, 0x12, 0x1e, 0x72, 0x3f, 0x09, 0x6c,
	0xc6, 0x81, 0x8e, 0xb2, 0x9a, 0xb1, 0x91, 0x84, 0xd6, 0x7d, 0xe6, 0xb3, 0xd8, 0x2f, 0x57, 0xb1,
	0xd7, 0x39, 0x33, 0xe0, 0xf5, 0x36, 0xf7, 0x0f, 0xfa, 0x3d, 0x2c, 0xc8, 0x37, 0xaa, 0x2d, 0xfa,
	0x08, 0x2a, 0xf8, 0x58, 0x7c, 0xc7, 0xa2, 0x40, 0x0c, 0x4d, 0xa3, 0x66, 0xd4, 0x2b, 0xbb, 0xe6,
	0x9f, 0x7f, 0xdc, 0x5b, 0x4f, 0xca, 0x3d, 0xee, 0xf5, 0x22, 0xc2, 0xf9, 0x13, 0x11, 0x05, 0xd4,
	0xf7, 0x46, 0x50, 0xf4, 0x19, 0x2c, 0xc5, 0x83, 0x9b, 0xf3, 0x35, 0xa3, 0x5e, 0x75, 0x6f, 0x35,
	0x34, 0xdc, 0x36, 0xe2, 0x26, 0xbb, 0x95, 0x17, 0x7f, 0x6f, 0xcd, 0xfd, 0x7e, 0x79, 0xba, 0x6d,
	0x78, 0x49, 0x56, 0xeb, 0xc3, 0x1f, 0x2f, 0x4f, 0xb7, 0x47, 0xf5, 0x7e, 0xbe, 0x3c, 0xdd, 0x76,
	0x12, 0x76, 0x9e, 0xe7, 0xf8, 0x79, 0x65, 0x5c, 0x67, 0x13, 0x36, 0x5e, 0x71, 0x79, 0x84, 0xf7,
	0x19, 0xe5, 0xc4, 0xf9, 0x6d, 0x01, 0x56, 0xda, 0xdc, 0xdf, 0x8b, 0x08, 0x16, 0xe4, 0xb1, 0xac,
	0x80, 0x5c, 0x58, 0xee, 0x4a, 0x93, 0x45, 0x13, 0xb7, 0x96, 0x02, 0xd1, 0x26, 0x94, 0x55, 0xfb,
	0x4e, 0xd0, 0x53, 0x5b, 0xab, 0x78, 0xcb, 0xca, 0xde, 0xef, 0xa1, 0x47, 0x00, 0x71, 0x48, 0x0c,
	0xfb, 0xc4, 0x2c, 0xd5, 0x8c, 0xfa, 0x8a, 0x6b, 0x6b, 0xf7, 0xad, 0xda, 0x3f, 0x1d, 0xf6, 0x89,
	0x57, 0xc1, 0xe9, 0x12, 0x21, 0x58, 0xa0, 0x38, 0x24, 0xe6, 0x82, 0xaa, 0xaa, 0xd6, 0xa8, 0x06,
	0xd5, 0x1e, 0xe1, 0xdd, 0x28, 0xe8, 0x4b, 0xad, 0x98, 0x8b, 0x2a, 0x94, 0x77, 0xa1, 0xaf, 0xa0,
	0x9c, 0x4a, 0xc9, 0x5c, 0x52, 0x54, 0xdf, 0xd6, 0xb6, 0xfc, 0x3a, 0x01, 0xed, 0xd3, 0x43, 0x96,
	0x27, 0x3c, 0xcb, 0x46, 0x5f, 0x02, 0xea, 0x32, 0x2a, 0x22, 0x76, 0x74, 0x44, 0xa2, 0x0e, 0x8e,
	0xb7, 0x6f, 0x2e, 0x4f, 0x20, 0x66, 0x75, 0x94, 0x93, 0x04, 0x50, 0x1b, 0xca, 0x21, 0x11, 0xb8,
	0x87, 0x05, 0x36, 0xcb, 0xb5, 0x52, 0xbd, 0xea, 0xee, 0x68, 0x47, 0x1a, 0x3f, 0x8d, 0x46, 0x3b,
	0xc9, 0xf9, 0x82, 0x8a, 0x68, 0xe8, 0x65, 0x25, 0xac, 0x87, 0x70, 0x63, 0x2c, 0x84, 0x6e, 0x42,
	0xe9, 0x7b, 0x92, 0xa8, 0xd1, 0x93, 0x4b, 0xb4, 0x0e, 0x8b, 0x27, 0xf8, 0xe8, 0x98, 0x24, 0x27,
	0x12, 0x1b, 0xad, 0xf9, 0x07, 0x46, 0xcb, 0x95, 0x3a, 0x4a, 0x0f, 0x4f, 0xaa, 0xe8, 0xb6, 0x5e,
	0x45, 0xb9, 0x41, 0x9c, 0x03, 0x78, 0x63, 0xdc, 0x93, 0x6a, 0x08, 0x3d, 0x84, 0x45, 0x95, 0xa5,
	0x7a, 0x57, 0x5d, 0xab, 0xf8, 0x70, 0xf3, 0x14, 0xc7, 0x39, 0xce, 0xbf, 0x06, 0xac, 0x65, 0xe2,
	0x54, 0xa0, 0x27, 0x02, 0x0b, 0x82, 0x1e, 0x00, 0x8c, 0x38, 0x9c, 0x28, 0xc4, 0x1c, 0xf6, 0x2a,
	0x2d, 0x7e, 0x0a, 0x15, 0x4a, 0x06, 0x1d, 0x2e, 0x3b, 0x24, 0x52, 0xdc, 0x2a, 0x9e, 0x56, 0x0d,
	0xe2, 0x95, 0x29, 0x19, 0xa8, 0x55, 0xab, 0x25, 0x59, 0xcb, 0x75, 0x92, 0xc4, 0xbd, 0x73, 0xd5,
	0xf5, 0x1b, 0x55, 0x71, 0xde, 0x82, 0x5b, 0x1a, 0x77, 0x76, 0x0d, 0xcf, 0xe6, 0x15, 0xbb, 0xb9,
	0x78, 0x7a, 0xb8, 0xd7, 0x43, 0xc4, 0x41, 0x4e, 0x8c, 0x25, 0x25, 0xc6, 0x4f, 0x8a, 0xc4, 0xa8,
	0x99, 0xe9, 0x7a, 0x44, 0xf9, 0x48, 0x43, 0xef, 0x7b, 0x13, 0xe9, 0x4d, 0xfb, 0x39, 0x35, 0xb0,
	0xf5, 0x91, 0x8c, 0xe4, 0x5f, 0xe6, 0xc1, 0x6a, 0x73, 0xff, 0x69, 0x84, 0x29, 0x3f, 0x24, 0x91,
	0x02, 0xed, 0x8d, 0xe8, 0x92, 0x37, 0xfd, 0x38, 0x8a, 0x08, 0x15, 0x9d, 0x19, 0x08, 0x5f, 0x4d,
	0x72, 0xf6, 0xa6, 0xe2, 0xfd, 0x73, 0x58, 0x91, 0x02, 0xcc, 0xd5, 0x2f, 0x4d, 0xa8, 0x7f, 0x83,
	0x92, 0xc1, 0xa8, 0x76, 0x6b, 0x5f, 0x92, 0xa4, 0x99, 0x53, 0x92, 0x75, 0x4f, 0x4f, 0x56, 0xc1,
	0x7e, 0x9d, 0x3b, 0xe0, 0x14, 0x47, 0x53, 0xd2, 0xdc, 0xb3, 0x05, 0x28, 0xb5, 0xb9, 0x8f, 0x9e,
	0xc1, 0x6b, 0x63, 0x7f, 0x81, 0x77, 0xae, 0xd6, 0x4b, 0x8c, 0xb2, 0xde, 0x9f, 0x06, 0x95, 0x3d,
	0x24, 0x1d, 0xa8, 0xe6, 0xff, 0x88, 0xde, 0x9e, 0xe2, 0x7d, 0xb4, 0xee, 0x4e, 0x01, 0xca, 0x1a,
	0x50, 0xb8, 0xf9, 0xbf, 0x87, 0xa6, 0x3e, 0x85, 0xf0, 0x15, 0xd2, 0xfa, 0x60, 0x5a, 0x64, 0xd6,
	0x6f, 0x00, 0x6b, 0xba, 0x2b, 0x7d, 0x77, 0x86, 0xbb, 0x66, 0xdd, 0x9f, 0x01, 0x9c, 0x35, 0xfe,
	0xc9, 0x80, 0x8d, 0x22, 0x9d, 0x37, 0x8b, 0x0a, 0x16, 0x24, 0x58, 0x1f, 0xcf, 0x98, 0x90, 0x4e,
	0x61, 0x2d, 0xfe, 0x20, 0x5f, 0xfa, 0x5d, 0xf7, 0xc5, 0xb9, 0x6d, 0xbc, 0x3c, 0xb7, 0x8d, 0x7f,
	0xce, 0x6d, 0xe3, 0xd7, 0x0b, 0x7b, 0xee, 0xe5, 0x85, 0x3d, 0xf7, 0xd7, 0x85, 0x3d, 0xf7, 0xad,
	0xa9, 0x51, 0xac, 0xfc, 0x4c, 0xe0, 0xcf, 0x96, 0xd4, 0xc7, 0xd7, 0xfd, 0xff, 0x02, 0x00, 0x00,
	0xff, 0xff, 0x39, 0xe6, 0x30, 0x8e, 0x9b, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	// CreateAsset creates a new asset
	CreateAsset(ctx context.Context, in *MsgCreateAsset, opts ...grpc.CallOption) (*MsgCreateAssetResponse, error)
	// UpdateAssetState updates the operational state of an asset
	UpdateAssetState(ctx context.Context, in *MsgUpdateAssetState, opts ...grpc.CallOption) (*MsgUpdateAssetStateResponse, error)
	// UpdateAssetMetadata updates the metadata of an asset
	UpdateAssetMetadata(ctx context.Context, in *MsgUpdateAssetMetadata, opts ...grpc.CallOption) (*MsgUpdateAssetMetadataResponse, error)
	// TransferAssetController transfers control of an asset to a new controller
	TransferAssetController(ctx context.Context, in *MsgTransferAssetController, opts ...grpc.CallOption) (*MsgTransferAssetControllerResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/acmain.assetmgmt.v1.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateAsset(ctx context.Context, in *MsgCreateAsset, opts ...grpc.CallOption) (*MsgCreateAssetResponse, error) {
	out := new(MsgCreateAssetResponse)
	err := c.cc.Invoke(ctx, "/acmain.assetmgmt.v1.Msg/CreateAsset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateAssetState(ctx context.Context, in *MsgUpdateAssetState, opts ...grpc.CallOption) (*MsgUpdateAssetStateResponse, error) {
	out := new(MsgUpdateAssetStateResponse)
	err := c.cc.Invoke(ctx, "/acmain.assetmgmt.v1.Msg/UpdateAssetState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateAssetMetadata(ctx context.Context, in *MsgUpdateAssetMetadata, opts ...grpc.CallOption) (*MsgUpdateAssetMetadataResponse, error) {
	out := new(MsgUpdateAssetMetadataResponse)
	err := c.cc.Invoke(ctx, "/acmain.assetmgmt.v1.Msg/UpdateAssetMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TransferAssetController(ctx context.Context, in *MsgTransferAssetController, opts ...grpc.CallOption) (*MsgTransferAssetControllerResponse, error) {
	out := new(MsgTransferAssetControllerResponse)
	err := c.cc.Invoke(ctx, "/acmain.assetmgmt.v1.Msg/TransferAssetController", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	// CreateAsset creates a new asset
	CreateAsset(context.Context, *MsgCreateAsset) (*MsgCreateAssetResponse, error)
	// UpdateAssetState updates the operational state of an asset
	UpdateAssetState(context.Context, *MsgUpdateAssetState) (*MsgUpdateAssetStateResponse, error)
	// UpdateAssetMetadata updates the metadata of an asset
	UpdateAssetMetadata(context.Context, *MsgUpdateAssetMetadata) (*MsgUpdateAssetMetadataResponse, error)
	// TransferAssetController transfers control of an asset to a new controller
	TransferAssetController(context.Context, *MsgTransferAssetController) (*MsgTransferAssetControllerResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (*UnimplementedMsgServer) CreateAsset(ctx context.Context, req *MsgCreateAsset) (*MsgCreateAssetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAsset not implemented")
}
func (*UnimplementedMsgServer) UpdateAssetState(ctx context.Context, req *MsgUpdateAssetState) (*MsgUpdateAssetStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAssetState not implemented")
}
func (*UnimplementedMsgServer) UpdateAssetMetadata(ctx context.Context, req *MsgUpdateAssetMetadata) (*MsgUpdateAssetMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAssetMetadata not implemented")
}
func (*UnimplementedMsgServer) TransferAssetController(ctx context.Context, req *MsgTransferAssetController) (*MsgTransferAssetControllerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferAssetController not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.assetmgmt.v1.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateAsset)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateAsset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.assetmgmt.v1.Msg/CreateAsset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateAsset(ctx, req.(*MsgCreateAsset))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateAssetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateAssetState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateAssetState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.assetmgmt.v1.Msg/UpdateAssetState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateAssetState(ctx, req.(*MsgUpdateAssetState))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateAssetMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateAssetMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateAssetMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.assetmgmt.v1.Msg/UpdateAssetMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateAssetMetadata(ctx, req.(*MsgUpdateAssetMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TransferAssetController_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTransferAssetController)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TransferAssetController(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.assetmgmt.v1.Msg/TransferAssetController",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TransferAssetController(ctx, req.(*MsgTransferAssetController))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "acmain.assetmgmt.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "CreateAsset",
			Handler:    _Msg_CreateAsset_Handler,
		},
		{
			MethodName: "UpdateAssetState",
			Handler:    _Msg_UpdateAssetState_Handler,
		},
		{
			MethodName: "UpdateAssetMetadata",
			Handler:    _Msg_UpdateAssetMetadata_Handler,
		},
		{
			MethodName: "TransferAssetController",
			Handler:    _Msg_TransferAssetController_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "acmain/assetmgmt/v1/tx.proto",
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCreateAsset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateAsset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateAsset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTx(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTx(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTx(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ControllerAddress) > 0 {
		i -= len(m.ControllerAddress)
		copy(dAtA[i:], m.ControllerAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ControllerAddress)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.AssetType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.AssetType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AssetId) > 0 {
		i -= len(m.AssetId)
		copy(dAtA[i:], m.AssetId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AssetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateAssetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateAssetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateAssetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgUpdateAssetState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateAssetState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateAssetState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewState != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.NewState))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AssetId) > 0 {
		i -= len(m.AssetId)
		copy(dAtA[i:], m.AssetId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AssetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Controller) > 0 {
		i -= len(m.Controller)
		copy(dAtA[i:], m.Controller)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Controller)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateAssetStateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateAssetStateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateAssetStateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateAssetMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateAssetMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateAssetMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTx(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTx(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTx(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AssetId) > 0 {
		i -= len(m.AssetId)
		copy(dAtA[i:], m.AssetId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AssetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Controller) > 0 {
		i -= len(m.Controller)
		copy(dAtA[i:], m.Controller)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Controller)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateAssetMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateAssetMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateAssetMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgTransferAssetController) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferAssetController) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferAssetController) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewController) > 0 {
		i -= len(m.NewController)
		copy(dAtA[i:], m.NewController)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewController)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AssetId) > 0 {
		i -= len(m.AssetId)
		copy(dAtA[i:], m.AssetId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AssetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CurrentController) > 0 {
		i -= len(m.CurrentController)
		copy(dAtA[i:], m.CurrentController)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CurrentController)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTransferAssetControllerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferAssetControllerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferAssetControllerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCreateAsset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.AssetId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.AssetType != 0 {
		n += 1 + sovTx(uint64(m.AssetType))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Location.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.ControllerAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTx(uint64(len(k))) + 1 + len(v) + sovTx(uint64(len(v)))
			n += mapEntrySize + 1 + sovTx(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MsgCreateAssetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Asset.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateAssetState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Controller)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.AssetId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.NewState != 0 {
		n += 1 + sovTx(uint64(m.NewState))
	}
	return n
}

func (m *MsgUpdateAssetStateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateAssetMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Controller)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.AssetId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTx(uint64(len(k))) + 1 + len(v) + sovTx(uint64(len(v)))
			n += mapEntrySize + 1 + sovTx(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MsgUpdateAssetMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgTransferAssetController) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CurrentController)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.AssetId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewController)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgTransferAssetControllerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateAsset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateAsset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateAsset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetType", wireType)
			}
			m.AssetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssetType |= AssetType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControllerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControllerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTx
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTx
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTx
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTx
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTx(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTx
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateAssetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateAssetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateAssetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateAssetState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateAssetState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateAssetState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewState", wireType)
			}
			m.NewState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewState |= AssetState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateAssetStateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateAssetStateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateAssetStateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateAssetMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateAssetMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateAssetMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTx
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTx
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTx
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTx
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTx(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTx
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateAssetMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateAssetMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateAssetMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferAssetController) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferAssetController: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferAssetController: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentController", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentController = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewController", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewController = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferAssetControllerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferAssetControllerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferAssetControllerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
