// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: acmain/iam/v1/query.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	query "github.com/cosmos/cosmos-sdk/types/query"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryParamsRequest is request type for the Query/Params RPC method.
type QueryParamsRequest struct {
}

func (m *QueryParamsRequest) Reset()         { *m = QueryParamsRequest{} }
func (m *QueryParamsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryParamsRequest) ProtoMessage()    {}
func (*QueryParamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{0}
}
func (m *QueryParamsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryParamsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryParamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParamsRequest.Merge(m, src)
}
func (m *QueryParamsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryParamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParamsRequest proto.InternalMessageInfo

// QueryParamsResponse is response type for the Query/Params RPC method.
type QueryParamsResponse struct {
	// params holds all the parameters of this module.
	Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *QueryParamsResponse) Reset()         { *m = QueryParamsResponse{} }
func (m *QueryParamsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryParamsResponse) ProtoMessage()    {}
func (*QueryParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{1}
}
func (m *QueryParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParamsResponse.Merge(m, src)
}
func (m *QueryParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParamsResponse proto.InternalMessageInfo

func (m *QueryParamsResponse) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// QueryDIDRequest is the request type for Query/DID RPC method
type QueryDIDRequest struct {
	// did is the Decentralized Identifier to query
	Did string `protobuf:"bytes,1,opt,name=did,proto3" json:"did,omitempty"`
}

func (m *QueryDIDRequest) Reset()         { *m = QueryDIDRequest{} }
func (m *QueryDIDRequest) String() string { return proto.CompactTextString(m) }
func (*QueryDIDRequest) ProtoMessage()    {}
func (*QueryDIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{2}
}
func (m *QueryDIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDIDRequest.Merge(m, src)
}
func (m *QueryDIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryDIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDIDRequest proto.InternalMessageInfo

func (m *QueryDIDRequest) GetDid() string {
	if m != nil {
		return m.Did
	}
	return ""
}

// QueryDIDResponse is the response type for Query/DID RPC method
type QueryDIDResponse struct {
	// did_document is the DID document
	DidDocument *DIDDocument `protobuf:"bytes,1,opt,name=did_document,json=didDocument,proto3" json:"did_document,omitempty"`
}

func (m *QueryDIDResponse) Reset()         { *m = QueryDIDResponse{} }
func (m *QueryDIDResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDIDResponse) ProtoMessage()    {}
func (*QueryDIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{3}
}
func (m *QueryDIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDIDResponse.Merge(m, src)
}
func (m *QueryDIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDIDResponse proto.InternalMessageInfo

func (m *QueryDIDResponse) GetDidDocument() *DIDDocument {
	if m != nil {
		return m.DidDocument
	}
	return nil
}

// QueryDIDsRequest is the request type for Query/DIDs RPC method
type QueryDIDsRequest struct {
	// pagination defines an optional pagination for the request.
	Pagination *query.PageRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
	// did_method filters results by DID method (optional)
	DidMethod DIDMethod `protobuf:"varint,2,opt,name=did_method,json=didMethod,proto3,enum=acmain.iam.v1.DIDMethod" json:"did_method,omitempty"`
	// deactivated_only filters to show only deactivated DIDs (optional)
	DeactivatedOnly bool `protobuf:"varint,3,opt,name=deactivated_only,json=deactivatedOnly,proto3" json:"deactivated_only,omitempty"`
}

func (m *QueryDIDsRequest) Reset()         { *m = QueryDIDsRequest{} }
func (m *QueryDIDsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryDIDsRequest) ProtoMessage()    {}
func (*QueryDIDsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{4}
}
func (m *QueryDIDsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDIDsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDIDsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDIDsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDIDsRequest.Merge(m, src)
}
func (m *QueryDIDsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryDIDsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDIDsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDIDsRequest proto.InternalMessageInfo

func (m *QueryDIDsRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *QueryDIDsRequest) GetDidMethod() DIDMethod {
	if m != nil {
		return m.DidMethod
	}
	return DID_METHOD_UNSPECIFIED
}

func (m *QueryDIDsRequest) GetDeactivatedOnly() bool {
	if m != nil {
		return m.DeactivatedOnly
	}
	return false
}

// QueryDIDsResponse is the response type for Query/DIDs RPC method
type QueryDIDsResponse struct {
	// did_documents are the DID documents
	DidDocuments []DIDDocument `protobuf:"bytes,1,rep,name=did_documents,json=didDocuments,proto3" json:"did_documents"`
	// pagination defines the pagination response.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryDIDsResponse) Reset()         { *m = QueryDIDsResponse{} }
func (m *QueryDIDsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDIDsResponse) ProtoMessage()    {}
func (*QueryDIDsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{5}
}
func (m *QueryDIDsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDIDsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDIDsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDIDsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDIDsResponse.Merge(m, src)
}
func (m *QueryDIDsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDIDsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDIDsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDIDsResponse proto.InternalMessageInfo

func (m *QueryDIDsResponse) GetDidDocuments() []DIDDocument {
	if m != nil {
		return m.DidDocuments
	}
	return nil
}

func (m *QueryDIDsResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryDIDsByControllerRequest is the request type for Query/DIDsByController RPC method
type QueryDIDsByControllerRequest struct {
	// controller is the Cosmos address that controls the DIDs
	Controller string `protobuf:"bytes,1,opt,name=controller,proto3" json:"controller,omitempty"`
	// pagination defines an optional pagination for the request.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryDIDsByControllerRequest) Reset()         { *m = QueryDIDsByControllerRequest{} }
func (m *QueryDIDsByControllerRequest) String() string { return proto.CompactTextString(m) }
func (*QueryDIDsByControllerRequest) ProtoMessage()    {}
func (*QueryDIDsByControllerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{6}
}
func (m *QueryDIDsByControllerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDIDsByControllerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDIDsByControllerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDIDsByControllerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDIDsByControllerRequest.Merge(m, src)
}
func (m *QueryDIDsByControllerRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryDIDsByControllerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDIDsByControllerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDIDsByControllerRequest proto.InternalMessageInfo

func (m *QueryDIDsByControllerRequest) GetController() string {
	if m != nil {
		return m.Controller
	}
	return ""
}

func (m *QueryDIDsByControllerRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryDIDsByControllerResponse is the response type for Query/DIDsByController RPC method
type QueryDIDsByControllerResponse struct {
	// did_documents are the DID documents
	DidDocuments []DIDDocument `protobuf:"bytes,1,rep,name=did_documents,json=didDocuments,proto3" json:"did_documents"`
	// pagination defines the pagination response.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryDIDsByControllerResponse) Reset()         { *m = QueryDIDsByControllerResponse{} }
func (m *QueryDIDsByControllerResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDIDsByControllerResponse) ProtoMessage()    {}
func (*QueryDIDsByControllerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{7}
}
func (m *QueryDIDsByControllerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDIDsByControllerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDIDsByControllerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDIDsByControllerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDIDsByControllerResponse.Merge(m, src)
}
func (m *QueryDIDsByControllerResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDIDsByControllerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDIDsByControllerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDIDsByControllerResponse proto.InternalMessageInfo

func (m *QueryDIDsByControllerResponse) GetDidDocuments() []DIDDocument {
	if m != nil {
		return m.DidDocuments
	}
	return nil
}

func (m *QueryDIDsByControllerResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryCredentialRequest is the request type for Query/Credential RPC method
type QueryCredentialRequest struct {
	// credential_id is the unique identifier of the credential
	CredentialId string `protobuf:"bytes,1,opt,name=credential_id,json=credentialId,proto3" json:"credential_id,omitempty"`
}

func (m *QueryCredentialRequest) Reset()         { *m = QueryCredentialRequest{} }
func (m *QueryCredentialRequest) String() string { return proto.CompactTextString(m) }
func (*QueryCredentialRequest) ProtoMessage()    {}
func (*QueryCredentialRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{8}
}
func (m *QueryCredentialRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryCredentialRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryCredentialRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryCredentialRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryCredentialRequest.Merge(m, src)
}
func (m *QueryCredentialRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryCredentialRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryCredentialRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryCredentialRequest proto.InternalMessageInfo

func (m *QueryCredentialRequest) GetCredentialId() string {
	if m != nil {
		return m.CredentialId
	}
	return ""
}

// QueryCredentialResponse is the response type for Query/Credential RPC method
type QueryCredentialResponse struct {
	// verifiable_credential is the credential data
	VerifiableCredential *VerifiableCredential `protobuf:"bytes,1,opt,name=verifiable_credential,json=verifiableCredential,proto3" json:"verifiable_credential,omitempty"`
}

func (m *QueryCredentialResponse) Reset()         { *m = QueryCredentialResponse{} }
func (m *QueryCredentialResponse) String() string { return proto.CompactTextString(m) }
func (*QueryCredentialResponse) ProtoMessage()    {}
func (*QueryCredentialResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{9}
}
func (m *QueryCredentialResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryCredentialResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryCredentialResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryCredentialResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryCredentialResponse.Merge(m, src)
}
func (m *QueryCredentialResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryCredentialResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryCredentialResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryCredentialResponse proto.InternalMessageInfo

func (m *QueryCredentialResponse) GetVerifiableCredential() *VerifiableCredential {
	if m != nil {
		return m.VerifiableCredential
	}
	return nil
}

// QueryCredentialsBySubjectRequest is the request type for Query/CredentialsBySubject RPC method
type QueryCredentialsBySubjectRequest struct {
	// subject is the DID of the credential subject
	Subject string `protobuf:"bytes,1,opt,name=subject,proto3" json:"subject,omitempty"`
	// pagination defines an optional pagination for the request.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
	// credential_type filters by credential type (optional)
	CredentialType CredentialType `protobuf:"varint,3,opt,name=credential_type,json=credentialType,proto3,enum=acmain.iam.v1.CredentialType" json:"credential_type,omitempty"`
	// include_expired includes expired credentials (default: false)
	IncludeExpired bool `protobuf:"varint,4,opt,name=include_expired,json=includeExpired,proto3" json:"include_expired,omitempty"`
}

func (m *QueryCredentialsBySubjectRequest) Reset()         { *m = QueryCredentialsBySubjectRequest{} }
func (m *QueryCredentialsBySubjectRequest) String() string { return proto.CompactTextString(m) }
func (*QueryCredentialsBySubjectRequest) ProtoMessage()    {}
func (*QueryCredentialsBySubjectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{10}
}
func (m *QueryCredentialsBySubjectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryCredentialsBySubjectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryCredentialsBySubjectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryCredentialsBySubjectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryCredentialsBySubjectRequest.Merge(m, src)
}
func (m *QueryCredentialsBySubjectRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryCredentialsBySubjectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryCredentialsBySubjectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryCredentialsBySubjectRequest proto.InternalMessageInfo

func (m *QueryCredentialsBySubjectRequest) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *QueryCredentialsBySubjectRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *QueryCredentialsBySubjectRequest) GetCredentialType() CredentialType {
	if m != nil {
		return m.CredentialType
	}
	return CREDENTIAL_TYPE_UNSPECIFIED
}

func (m *QueryCredentialsBySubjectRequest) GetIncludeExpired() bool {
	if m != nil {
		return m.IncludeExpired
	}
	return false
}

// QueryCredentialsBySubjectResponse is the response type for Query/CredentialsBySubject RPC method
type QueryCredentialsBySubjectResponse struct {
	// verifiable_credentials are the subject's credentials
	VerifiableCredentials []VerifiableCredential `protobuf:"bytes,1,rep,name=verifiable_credentials,json=verifiableCredentials,proto3" json:"verifiable_credentials"`
	// pagination defines the pagination response.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryCredentialsBySubjectResponse) Reset()         { *m = QueryCredentialsBySubjectResponse{} }
func (m *QueryCredentialsBySubjectResponse) String() string { return proto.CompactTextString(m) }
func (*QueryCredentialsBySubjectResponse) ProtoMessage()    {}
func (*QueryCredentialsBySubjectResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{11}
}
func (m *QueryCredentialsBySubjectResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryCredentialsBySubjectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryCredentialsBySubjectResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryCredentialsBySubjectResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryCredentialsBySubjectResponse.Merge(m, src)
}
func (m *QueryCredentialsBySubjectResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryCredentialsBySubjectResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryCredentialsBySubjectResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryCredentialsBySubjectResponse proto.InternalMessageInfo

func (m *QueryCredentialsBySubjectResponse) GetVerifiableCredentials() []VerifiableCredential {
	if m != nil {
		return m.VerifiableCredentials
	}
	return nil
}

func (m *QueryCredentialsBySubjectResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryCredentialsByIssuerRequest is the request type for Query/CredentialsByIssuer RPC method
type QueryCredentialsByIssuerRequest struct {
	// issuer is the Cosmos address of the credential issuer
	Issuer string `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// pagination defines an optional pagination for the request.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
	// credential_type filters by credential type (optional)
	CredentialType CredentialType `protobuf:"varint,3,opt,name=credential_type,json=credentialType,proto3,enum=acmain.iam.v1.CredentialType" json:"credential_type,omitempty"`
}

func (m *QueryCredentialsByIssuerRequest) Reset()         { *m = QueryCredentialsByIssuerRequest{} }
func (m *QueryCredentialsByIssuerRequest) String() string { return proto.CompactTextString(m) }
func (*QueryCredentialsByIssuerRequest) ProtoMessage()    {}
func (*QueryCredentialsByIssuerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{12}
}
func (m *QueryCredentialsByIssuerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryCredentialsByIssuerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryCredentialsByIssuerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryCredentialsByIssuerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryCredentialsByIssuerRequest.Merge(m, src)
}
func (m *QueryCredentialsByIssuerRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryCredentialsByIssuerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryCredentialsByIssuerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryCredentialsByIssuerRequest proto.InternalMessageInfo

func (m *QueryCredentialsByIssuerRequest) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *QueryCredentialsByIssuerRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *QueryCredentialsByIssuerRequest) GetCredentialType() CredentialType {
	if m != nil {
		return m.CredentialType
	}
	return CREDENTIAL_TYPE_UNSPECIFIED
}

// QueryCredentialsByIssuerResponse is the response type for Query/CredentialsByIssuer RPC method
type QueryCredentialsByIssuerResponse struct {
	// verifiable_credentials are the credentials issued
	VerifiableCredentials []VerifiableCredential `protobuf:"bytes,1,rep,name=verifiable_credentials,json=verifiableCredentials,proto3" json:"verifiable_credentials"`
	// pagination defines the pagination response.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
	// total_issued is the total number of credentials issued by this issuer
	TotalIssued uint64 `protobuf:"varint,3,opt,name=total_issued,json=totalIssued,proto3" json:"total_issued,omitempty"`
}

func (m *QueryCredentialsByIssuerResponse) Reset()         { *m = QueryCredentialsByIssuerResponse{} }
func (m *QueryCredentialsByIssuerResponse) String() string { return proto.CompactTextString(m) }
func (*QueryCredentialsByIssuerResponse) ProtoMessage()    {}
func (*QueryCredentialsByIssuerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{13}
}
func (m *QueryCredentialsByIssuerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryCredentialsByIssuerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryCredentialsByIssuerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryCredentialsByIssuerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryCredentialsByIssuerResponse.Merge(m, src)
}
func (m *QueryCredentialsByIssuerResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryCredentialsByIssuerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryCredentialsByIssuerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryCredentialsByIssuerResponse proto.InternalMessageInfo

func (m *QueryCredentialsByIssuerResponse) GetVerifiableCredentials() []VerifiableCredential {
	if m != nil {
		return m.VerifiableCredentials
	}
	return nil
}

func (m *QueryCredentialsByIssuerResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *QueryCredentialsByIssuerResponse) GetTotalIssued() uint64 {
	if m != nil {
		return m.TotalIssued
	}
	return 0
}

// QueryIsCredentialValidRequest is the request type for Query/IsCredentialValid RPC method
type QueryIsCredentialValidRequest struct {
	// credential_id is the unique identifier of the credential
	CredentialId string `protobuf:"bytes,1,opt,name=credential_id,json=credentialId,proto3" json:"credential_id,omitempty"`
	// at_timestamp checks validity at a specific time (optional, defaults to current block time)
	AtTimestamp *time.Time `protobuf:"bytes,2,opt,name=at_timestamp,json=atTimestamp,proto3,stdtime" json:"at_timestamp,omitempty"`
}

func (m *QueryIsCredentialValidRequest) Reset()         { *m = QueryIsCredentialValidRequest{} }
func (m *QueryIsCredentialValidRequest) String() string { return proto.CompactTextString(m) }
func (*QueryIsCredentialValidRequest) ProtoMessage()    {}
func (*QueryIsCredentialValidRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{14}
}
func (m *QueryIsCredentialValidRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryIsCredentialValidRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryIsCredentialValidRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryIsCredentialValidRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryIsCredentialValidRequest.Merge(m, src)
}
func (m *QueryIsCredentialValidRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryIsCredentialValidRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryIsCredentialValidRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryIsCredentialValidRequest proto.InternalMessageInfo

func (m *QueryIsCredentialValidRequest) GetCredentialId() string {
	if m != nil {
		return m.CredentialId
	}
	return ""
}

func (m *QueryIsCredentialValidRequest) GetAtTimestamp() *time.Time {
	if m != nil {
		return m.AtTimestamp
	}
	return nil
}

// QueryIsCredentialValidResponse is the response type for Query/IsCredentialValid RPC method
type QueryIsCredentialValidResponse struct {
	// valid indicates if the credential is valid
	Valid bool `protobuf:"varint,1,opt,name=valid,proto3" json:"valid,omitempty"`
	// reason explains why the credential is invalid (empty if valid)
	Reason string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	// status is the current credential status
	Status CredentialStatus `protobuf:"varint,3,opt,name=status,proto3,enum=acmain.iam.v1.CredentialStatus" json:"status,omitempty"`
	// expires_at is the expiration time (null if already expired)
	ExpiresAt *time.Time `protobuf:"bytes,4,opt,name=expires_at,json=expiresAt,proto3,stdtime" json:"expires_at,omitempty"`
}

func (m *QueryIsCredentialValidResponse) Reset()         { *m = QueryIsCredentialValidResponse{} }
func (m *QueryIsCredentialValidResponse) String() string { return proto.CompactTextString(m) }
func (*QueryIsCredentialValidResponse) ProtoMessage()    {}
func (*QueryIsCredentialValidResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{15}
}
func (m *QueryIsCredentialValidResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryIsCredentialValidResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryIsCredentialValidResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryIsCredentialValidResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryIsCredentialValidResponse.Merge(m, src)
}
func (m *QueryIsCredentialValidResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryIsCredentialValidResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryIsCredentialValidResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryIsCredentialValidResponse proto.InternalMessageInfo

func (m *QueryIsCredentialValidResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *QueryIsCredentialValidResponse) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *QueryIsCredentialValidResponse) GetStatus() CredentialStatus {
	if m != nil {
		return m.Status
	}
	return CREDENTIAL_STATUS_UNSPECIFIED
}

func (m *QueryIsCredentialValidResponse) GetExpiresAt() *time.Time {
	if m != nil {
		return m.ExpiresAt
	}
	return nil
}

// QueryDeviceKeyRequest is the request type for Query/DeviceKey RPC method
type QueryDeviceKeyRequest struct {
	// device_id is the unique identifier of the IoT device
	DeviceId string `protobuf:"bytes,1,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
}

func (m *QueryDeviceKeyRequest) Reset()         { *m = QueryDeviceKeyRequest{} }
func (m *QueryDeviceKeyRequest) String() string { return proto.CompactTextString(m) }
func (*QueryDeviceKeyRequest) ProtoMessage()    {}
func (*QueryDeviceKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{16}
}
func (m *QueryDeviceKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDeviceKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDeviceKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDeviceKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDeviceKeyRequest.Merge(m, src)
}
func (m *QueryDeviceKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryDeviceKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDeviceKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDeviceKeyRequest proto.InternalMessageInfo

func (m *QueryDeviceKeyRequest) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

// QueryDeviceKeyResponse is the response type for Query/DeviceKey RPC method
type QueryDeviceKeyResponse struct {
	// device_key is the device's key information
	DeviceKey *DeviceKey `protobuf:"bytes,1,opt,name=device_key,json=deviceKey,proto3" json:"device_key,omitempty"`
}

func (m *QueryDeviceKeyResponse) Reset()         { *m = QueryDeviceKeyResponse{} }
func (m *QueryDeviceKeyResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDeviceKeyResponse) ProtoMessage()    {}
func (*QueryDeviceKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{17}
}
func (m *QueryDeviceKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDeviceKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDeviceKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDeviceKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDeviceKeyResponse.Merge(m, src)
}
func (m *QueryDeviceKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDeviceKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDeviceKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDeviceKeyResponse proto.InternalMessageInfo

func (m *QueryDeviceKeyResponse) GetDeviceKey() *DeviceKey {
	if m != nil {
		return m.DeviceKey
	}
	return nil
}

// QueryDeviceKeysByOwnerRequest is the request type for Query/DeviceKeysByOwner RPC method
type QueryDeviceKeysByOwnerRequest struct {
	// owner is the Cosmos address that owns the devices
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// pagination defines an optional pagination for the request.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
	// device_type filters by device type (optional, e.g., "smart_lock", "sensor")
	DeviceType string `protobuf:"bytes,3,opt,name=device_type,json=deviceType,proto3" json:"device_type,omitempty"`
	// include_inactive includes inactive/revoked device keys (default: false)
	IncludeInactive bool `protobuf:"varint,4,opt,name=include_inactive,json=includeInactive,proto3" json:"include_inactive,omitempty"`
}

func (m *QueryDeviceKeysByOwnerRequest) Reset()         { *m = QueryDeviceKeysByOwnerRequest{} }
func (m *QueryDeviceKeysByOwnerRequest) String() string { return proto.CompactTextString(m) }
func (*QueryDeviceKeysByOwnerRequest) ProtoMessage()    {}
func (*QueryDeviceKeysByOwnerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{18}
}
func (m *QueryDeviceKeysByOwnerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDeviceKeysByOwnerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDeviceKeysByOwnerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDeviceKeysByOwnerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDeviceKeysByOwnerRequest.Merge(m, src)
}
func (m *QueryDeviceKeysByOwnerRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryDeviceKeysByOwnerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDeviceKeysByOwnerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDeviceKeysByOwnerRequest proto.InternalMessageInfo

func (m *QueryDeviceKeysByOwnerRequest) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *QueryDeviceKeysByOwnerRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *QueryDeviceKeysByOwnerRequest) GetDeviceType() string {
	if m != nil {
		return m.DeviceType
	}
	return ""
}

func (m *QueryDeviceKeysByOwnerRequest) GetIncludeInactive() bool {
	if m != nil {
		return m.IncludeInactive
	}
	return false
}

// QueryDeviceKeysByOwnerResponse is the response type for Query/DeviceKeysByOwner RPC method
type QueryDeviceKeysByOwnerResponse struct {
	// device_keys are the owner's device keys
	DeviceKeys []DeviceKey `protobuf:"bytes,1,rep,name=device_keys,json=deviceKeys,proto3" json:"device_keys"`
	// pagination defines the pagination response.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryDeviceKeysByOwnerResponse) Reset()         { *m = QueryDeviceKeysByOwnerResponse{} }
func (m *QueryDeviceKeysByOwnerResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDeviceKeysByOwnerResponse) ProtoMessage()    {}
func (*QueryDeviceKeysByOwnerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{19}
}
func (m *QueryDeviceKeysByOwnerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDeviceKeysByOwnerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDeviceKeysByOwnerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDeviceKeysByOwnerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDeviceKeysByOwnerResponse.Merge(m, src)
}
func (m *QueryDeviceKeysByOwnerResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDeviceKeysByOwnerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDeviceKeysByOwnerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDeviceKeysByOwnerResponse proto.InternalMessageInfo

func (m *QueryDeviceKeysByOwnerResponse) GetDeviceKeys() []DeviceKey {
	if m != nil {
		return m.DeviceKeys
	}
	return nil
}

func (m *QueryDeviceKeysByOwnerResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryDeviceKeysByLocationRequest is the request type for Query/DeviceKeysByLocation RPC method
type QueryDeviceKeysByLocationRequest struct {
	// location is the physical location to query (e.g., "building-a:floor-2:zone-1")
	Location string `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	// pagination defines an optional pagination for the request.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
	// device_type filters by device type (optional)
	DeviceType string `protobuf:"bytes,3,opt,name=device_type,json=deviceType,proto3" json:"device_type,omitempty"`
	// include_inactive includes inactive/revoked device keys (default: false)
	IncludeInactive bool `protobuf:"varint,4,opt,name=include_inactive,json=includeInactive,proto3" json:"include_inactive,omitempty"`
}

func (m *QueryDeviceKeysByLocationRequest) Reset()         { *m = QueryDeviceKeysByLocationRequest{} }
func (m *QueryDeviceKeysByLocationRequest) String() string { return proto.CompactTextString(m) }
func (*QueryDeviceKeysByLocationRequest) ProtoMessage()    {}
func (*QueryDeviceKeysByLocationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{20}
}
func (m *QueryDeviceKeysByLocationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDeviceKeysByLocationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDeviceKeysByLocationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDeviceKeysByLocationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDeviceKeysByLocationRequest.Merge(m, src)
}
func (m *QueryDeviceKeysByLocationRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryDeviceKeysByLocationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDeviceKeysByLocationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDeviceKeysByLocationRequest proto.InternalMessageInfo

func (m *QueryDeviceKeysByLocationRequest) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *QueryDeviceKeysByLocationRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *QueryDeviceKeysByLocationRequest) GetDeviceType() string {
	if m != nil {
		return m.DeviceType
	}
	return ""
}

func (m *QueryDeviceKeysByLocationRequest) GetIncludeInactive() bool {
	if m != nil {
		return m.IncludeInactive
	}
	return false
}

// QueryDeviceKeysByLocationResponse is the response type for Query/DeviceKeysByLocation RPC method
type QueryDeviceKeysByLocationResponse struct {
	// device_keys are the devices at the location
	DeviceKeys []DeviceKey `protobuf:"bytes,1,rep,name=device_keys,json=deviceKeys,proto3" json:"device_keys"`
	// pagination defines the pagination response.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
	// total_count is the total number of devices at this location
	TotalCount uint64 `protobuf:"varint,3,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
}

func (m *QueryDeviceKeysByLocationResponse) Reset()         { *m = QueryDeviceKeysByLocationResponse{} }
func (m *QueryDeviceKeysByLocationResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDeviceKeysByLocationResponse) ProtoMessage()    {}
func (*QueryDeviceKeysByLocationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{21}
}
func (m *QueryDeviceKeysByLocationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDeviceKeysByLocationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDeviceKeysByLocationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDeviceKeysByLocationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDeviceKeysByLocationResponse.Merge(m, src)
}
func (m *QueryDeviceKeysByLocationResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDeviceKeysByLocationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDeviceKeysByLocationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDeviceKeysByLocationResponse proto.InternalMessageInfo

func (m *QueryDeviceKeysByLocationResponse) GetDeviceKeys() []DeviceKey {
	if m != nil {
		return m.DeviceKeys
	}
	return nil
}

func (m *QueryDeviceKeysByLocationResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *QueryDeviceKeysByLocationResponse) GetTotalCount() uint64 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

// QueryPublicKeyRequest is the request type for Query/PublicKey RPC method
type QueryPublicKeyRequest struct {
	// did is the Decentralized Identifier
	Did string `protobuf:"bytes,1,opt,name=did,proto3" json:"did,omitempty"`
	// key_id is the identifier of the key within the DID document
	KeyId string `protobuf:"bytes,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *QueryPublicKeyRequest) Reset()         { *m = QueryPublicKeyRequest{} }
func (m *QueryPublicKeyRequest) String() string { return proto.CompactTextString(m) }
func (*QueryPublicKeyRequest) ProtoMessage()    {}
func (*QueryPublicKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{22}
}
func (m *QueryPublicKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPublicKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPublicKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPublicKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPublicKeyRequest.Merge(m, src)
}
func (m *QueryPublicKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryPublicKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPublicKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPublicKeyRequest proto.InternalMessageInfo

func (m *QueryPublicKeyRequest) GetDid() string {
	if m != nil {
		return m.Did
	}
	return ""
}

func (m *QueryPublicKeyRequest) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

// QueryPublicKeyResponse is the response type for Query/PublicKey RPC method
type QueryPublicKeyResponse struct {
	// public_key_info is the public key information
	PublicKeyInfo *PublicKeyInfo `protobuf:"bytes,1,opt,name=public_key_info,json=publicKeyInfo,proto3" json:"public_key_info,omitempty"`
}

func (m *QueryPublicKeyResponse) Reset()         { *m = QueryPublicKeyResponse{} }
func (m *QueryPublicKeyResponse) String() string { return proto.CompactTextString(m) }
func (*QueryPublicKeyResponse) ProtoMessage()    {}
func (*QueryPublicKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_71422d7752b362a4, []int{23}
}
func (m *QueryPublicKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPublicKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPublicKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPublicKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPublicKeyResponse.Merge(m, src)
}
func (m *QueryPublicKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryPublicKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPublicKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPublicKeyResponse proto.InternalMessageInfo

func (m *QueryPublicKeyResponse) GetPublicKeyInfo() *PublicKeyInfo {
	if m != nil {
		return m.PublicKeyInfo
	}
	return nil
}

func init() {
	proto.RegisterType((*QueryParamsRequest)(nil), "acmain.iam.v1.QueryParamsRequest")
	proto.RegisterType((*QueryParamsResponse)(nil), "acmain.iam.v1.QueryParamsResponse")
	proto.RegisterType((*QueryDIDRequest)(nil), "acmain.iam.v1.QueryDIDRequest")
	proto.RegisterType((*QueryDIDResponse)(nil), "acmain.iam.v1.QueryDIDResponse")
	proto.RegisterType((*QueryDIDsRequest)(nil), "acmain.iam.v1.QueryDIDsRequest")
	proto.RegisterType((*QueryDIDsResponse)(nil), "acmain.iam.v1.QueryDIDsResponse")
	proto.RegisterType((*QueryDIDsByControllerRequest)(nil), "acmain.iam.v1.QueryDIDsByControllerRequest")
	proto.RegisterType((*QueryDIDsByControllerResponse)(nil), "acmain.iam.v1.QueryDIDsByControllerResponse")
	proto.RegisterType((*QueryCredentialRequest)(nil), "acmain.iam.v1.QueryCredentialRequest")
	proto.RegisterType((*QueryCredentialResponse)(nil), "acmain.iam.v1.QueryCredentialResponse")
	proto.RegisterType((*QueryCredentialsBySubjectRequest)(nil), "acmain.iam.v1.QueryCredentialsBySubjectRequest")
	proto.RegisterType((*QueryCredentialsBySubjectResponse)(nil), "acmain.iam.v1.QueryCredentialsBySubjectResponse")
	proto.RegisterType((*QueryCredentialsByIssuerRequest)(nil), "acmain.iam.v1.QueryCredentialsByIssuerRequest")
	proto.RegisterType((*QueryCredentialsByIssuerResponse)(nil), "acmain.iam.v1.QueryCredentialsByIssuerResponse")
	proto.RegisterType((*QueryIsCredentialValidRequest)(nil), "acmain.iam.v1.QueryIsCredentialValidRequest")
	proto.RegisterType((*QueryIsCredentialValidResponse)(nil), "acmain.iam.v1.QueryIsCredentialValidResponse")
	proto.RegisterType((*QueryDeviceKeyRequest)(nil), "acmain.iam.v1.QueryDeviceKeyRequest")
	proto.RegisterType((*QueryDeviceKeyResponse)(nil), "acmain.iam.v1.QueryDeviceKeyResponse")
	proto.RegisterType((*QueryDeviceKeysByOwnerRequest)(nil), "acmain.iam.v1.QueryDeviceKeysByOwnerRequest")
	proto.RegisterType((*QueryDeviceKeysByOwnerResponse)(nil), "acmain.iam.v1.QueryDeviceKeysByOwnerResponse")
	proto.RegisterType((*QueryDeviceKeysByLocationRequest)(nil), "acmain.iam.v1.QueryDeviceKeysByLocationRequest")
	proto.RegisterType((*QueryDeviceKeysByLocationResponse)(nil), "acmain.iam.v1.QueryDeviceKeysByLocationResponse")
	proto.RegisterType((*QueryPublicKeyRequest)(nil), "acmain.iam.v1.QueryPublicKeyRequest")
	proto.RegisterType((*QueryPublicKeyResponse)(nil), "acmain.iam.v1.QueryPublicKeyResponse")
}

func init() { proto.RegisterFile("acmain/iam/v1/query.proto", fileDescriptor_71422d7752b362a4) }

var fileDescriptor_71422d7752b362a4 = []byte{
	// 1604 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0xcb, 0x6f, 0xdb, 0x46,
	0x13, 0x37, 0xfd, 0xfa, 0xac, 0xf1, 0x7b, 0x63, 0xfb, 0xd3, 0xc7, 0xcf, 0x91, 0x14, 0x3a, 0x0f,
	0x27, 0x8d, 0xc5, 0xd8, 0x79, 0xd8, 0x09, 0x9a, 0x26, 0x91, 0xd5, 0x14, 0x6a, 0x5a, 0x24, 0x61,
	0x82, 0xa0, 0xe8, 0xa1, 0x02, 0xa5, 0x5d, 0xab, 0x6c, 0x24, 0x52, 0x11, 0x29, 0x35, 0x82, 0xa0,
	0x4b, 0x6f, 0x3d, 0x35, 0x68, 0x81, 0x9e, 0x7b, 0xcc, 0xa1, 0x40, 0x5b, 0x20, 0x97, 0xa2, 0x40,
	0xcf, 0x39, 0x06, 0xc9, 0xa5, 0xa7, 0xb6, 0xb0, 0x0b, 0xf4, 0x2f, 0xe8, 0xbd, 0xe0, 0x72, 0x48,
	0x51, 0x14, 0x69, 0x29, 0x85, 0x0f, 0xee, 0x45, 0xe2, 0xce, 0xce, 0xee, 0xfc, 0xe6, 0x37, 0x3b,
	0xb3, 0xb3, 0xf0, 0x3f, 0xb5, 0x58, 0x51, 0x35, 0x5d, 0xd6, 0xd4, 0x8a, 0xdc, 0x58, 0x97, 0x1f,
	0xd5, 0x59, 0xad, 0x99, 0xae, 0xd6, 0x0c, 0xcb, 0x20, 0xd3, 0xce, 0x54, 0x5a, 0x53, 0x2b, 0xe9,
	0xc6, 0xba, 0x98, 0xe8, 0xd6, 0xa4, 0xac, 0xa1, 0x15, 0x59, 0xfe, 0x21, 0x43, 0x75, 0x31, 0x15,
	0x98, 0xd7, 0x68, 0x9e, 0x1a, 0xc5, 0x7a, 0x85, 0xe9, 0x16, 0x6a, 0x04, 0x6c, 0x31, 0xbd, 0x5e,
	0x31, 0x71, 0x4a, 0xec, 0x9e, 0xaa, 0xaa, 0x35, 0xd5, 0x9b, 0x5b, 0x09, 0xcc, 0xd5, 0x0b, 0x65,
	0xad, 0x68, 0x1b, 0xce, 0x6b, 0xfa, 0x8e, 0x81, 0x4a, 0xa7, 0xbb, 0x95, 0x1a, 0xac, 0xa6, 0xed,
	0x68, 0x6a, 0xa1, 0xcc, 0xf2, 0xc5, 0x1a, 0xa3, 0x4c, 0xb7, 0x34, 0xb5, 0x8c, 0xaa, 0xf3, 0x6a,
	0x45, 0xd3, 0x0d, 0x99, 0xff, 0xa2, 0xe8, 0x4c, 0xd1, 0x30, 0x2b, 0x86, 0x29, 0x17, 0x54, 0x93,
	0x39, 0x1c, 0xc8, 0x8d, 0xf5, 0x02, 0xb3, 0x54, 0x1b, 0x4a, 0x49, 0xd3, 0x55, 0x4b, 0x33, 0x74,
	0xd7, 0x0b, 0x47, 0x37, 0xcf, 0x47, 0xb2, 0x33, 0xc0, 0xa9, 0x85, 0x92, 0x51, 0x32, 0x1c, 0xb9,
	0xfd, 0x85, 0xd2, 0xe5, 0x92, 0x61, 0x94, 0xca, 0x4c, 0x56, 0xab, 0x9a, 0xac, 0xea, 0xba, 0x61,
	0xf1, 0xdd, 0xdc, 0x35, 0x49, 0x9c, 0xe5, 0xa3, 0x42, 0x7d, 0x47, 0xb6, 0xb4, 0x0a, 0x33, 0x2d,
	0xb5, 0x52, 0x75, 0x14, 0xa4, 0x05, 0x20, 0x77, 0x6d, 0x44, 0x77, 0x38, 0x27, 0x0a, 0x7b, 0x54,
	0x67, 0xa6, 0x25, 0xdd, 0x86, 0x23, 0x5d, 0x52, 0xb3, 0x6a, 0xe8, 0x26, 0x23, 0x5b, 0x30, 0xee,
	0x70, 0x17, 0x17, 0x52, 0xc2, 0xea, 0xe4, 0xc6, 0x62, 0xba, 0x2b, 0x88, 0x69, 0x47, 0x3d, 0x13,
	0x7b, 0xfe, 0x6b, 0x72, 0xe8, 0xe9, 0x9f, 0xdf, 0x9f, 0x11, 0x14, 0xd4, 0x97, 0x56, 0x60, 0x96,
	0x6f, 0x98, 0xcd, 0x65, 0xd1, 0x06, 0x99, 0x83, 0x11, 0xaa, 0x51, 0xbe, 0x53, 0x4c, 0xb1, 0x3f,
	0xa5, 0xbb, 0x30, 0xd7, 0x51, 0x42, 0x93, 0x57, 0x61, 0xca, 0x1f, 0x6b, 0x34, 0x2c, 0x06, 0x0c,
	0x67, 0x73, 0xd9, 0x2c, 0x6a, 0x28, 0x93, 0x54, 0xa3, 0xee, 0x40, 0xfa, 0x59, 0xe8, 0xec, 0xe9,
	0x7a, 0x47, 0x6e, 0x02, 0x74, 0x78, 0xc7, 0x1d, 0x4f, 0xa6, 0x91, 0x6b, 0x3b, 0x48, 0x69, 0xe7,
	0xa0, 0x62, 0x90, 0xd2, 0x77, 0xd4, 0x12, 0xc3, 0xb5, 0x8a, 0x6f, 0x25, 0xd9, 0x04, 0xb0, 0xb1,
	0x55, 0x98, 0xf5, 0xb1, 0x41, 0xe3, 0xc3, 0x29, 0x61, 0x75, 0x66, 0x23, 0xde, 0x8b, 0xec, 0x7d,
	0x3e, 0xaf, 0xc4, 0xa8, 0x46, 0x9d, 0x4f, 0x72, 0x1a, 0xe6, 0x28, 0x53, 0x8b, 0x96, 0xd6, 0x50,
	0x2d, 0x46, 0xf3, 0x86, 0x5e, 0x6e, 0xc6, 0x47, 0x52, 0xc2, 0xea, 0x84, 0x32, 0xeb, 0x93, 0xdf,
	0xd6, 0xcb, 0x4d, 0xe9, 0xa9, 0x00, 0xf3, 0x3e, 0x07, 0x90, 0x95, 0x77, 0x61, 0xda, 0xcf, 0x8a,
	0x1d, 0x8f, 0x91, 0xfd, 0x69, 0xf1, 0x07, 0x65, 0xca, 0xc7, 0x90, 0x49, 0xde, 0xe9, 0x62, 0x63,
	0x98, 0xb3, 0x71, 0xaa, 0x2f, 0x1b, 0x0e, 0x10, 0x3f, 0x1d, 0xd2, 0x37, 0x02, 0x2c, 0x7b, 0x50,
	0x33, 0xcd, 0x6d, 0x43, 0xb7, 0x6a, 0x46, 0xb9, 0xcc, 0x6a, 0x2e, 0xef, 0x5b, 0x00, 0x45, 0x4f,
	0xe8, 0x04, 0x3e, 0x13, 0x7f, 0xf9, 0x6c, 0x6d, 0x01, 0x8d, 0xdd, 0xa0, 0xb4, 0xc6, 0x4c, 0xf3,
	0x9e, 0x55, 0xd3, 0xf4, 0x92, 0xe2, 0xd3, 0x0d, 0x44, 0x6c, 0xf8, 0x9f, 0x46, 0x4c, 0x7a, 0x26,
	0xc0, 0xd1, 0x08, 0x88, 0x87, 0x99, 0xd9, 0xab, 0xb0, 0xc4, 0x51, 0x6f, 0x7b, 0xc5, 0xc6, 0xa5,
	0x74, 0x05, 0xa6, 0x3b, 0x15, 0x28, 0xef, 0xa5, 0xd3, 0x54, 0x47, 0x98, 0xa3, 0x92, 0x09, 0xff,
	0xed, 0x59, 0x8e, 0xee, 0x7e, 0x00, 0x8b, 0xa1, 0xc5, 0x0c, 0xb3, 0x62, 0x25, 0xe0, 0xf6, 0x03,
	0x4f, 0xd7, 0xb7, 0xd7, 0x42, 0x23, 0x44, 0x2a, 0xfd, 0x25, 0x40, 0x2a, 0x60, 0xd5, 0xcc, 0x34,
	0xef, 0xd5, 0x0b, 0x9f, 0xb0, 0xa2, 0xe5, 0xc2, 0x8f, 0xc3, 0x7f, 0x4c, 0x47, 0x82, 0xc0, 0xdd,
	0xe1, 0x41, 0x45, 0x9c, 0xdc, 0x84, 0x59, 0x1f, 0x41, 0x56, 0xb3, 0xca, 0x78, 0xa6, 0xcd, 0x6c,
	0x1c, 0x0d, 0xb8, 0xd6, 0x81, 0x79, 0xbf, 0x59, 0x65, 0xca, 0x4c, 0xb1, 0x6b, 0x4c, 0x4e, 0xc1,
	0xac, 0xa6, 0x17, 0xcb, 0x75, 0xca, 0xf2, 0xec, 0x71, 0x55, 0xab, 0x31, 0x1a, 0x1f, 0xe5, 0x19,
	0x3b, 0x83, 0xe2, 0xb7, 0x1d, 0xa9, 0xf4, 0x4a, 0x80, 0x63, 0xfb, 0xf8, 0x8d, 0xbc, 0x33, 0x58,
	0x0a, 0xe5, 0xdd, 0x3d, 0x6f, 0x83, 0x10, 0xef, 0x3f, 0x78, 0x8b, 0x61, 0x31, 0x38, 0xc0, 0x13,
	0xb8, 0x27, 0x40, 0xb2, 0xd7, 0xab, 0x9c, 0x69, 0xd6, 0x3b, 0xe9, 0x7d, 0x0e, 0xc6, 0x35, 0x2e,
	0xe8, 0x9b, 0xda, 0xa8, 0x77, 0xd8, 0x82, 0x1c, 0x71, 0x66, 0x5d, 0x2f, 0xff, 0x9d, 0xa1, 0x23,
	0xc7, 0x60, 0xca, 0x32, 0x2c, 0xbb, 0x3a, 0xd8, 0x7e, 0x50, 0xce, 0xcc, 0xa8, 0x32, 0xc9, 0x65,
	0xdc, 0x35, 0x2a, 0x7d, 0xee, 0x96, 0xc5, 0x9c, 0xd9, 0x81, 0xf0, 0x40, 0x2d, 0x6b, 0xf4, 0x75,
	0xea, 0x0c, 0xd9, 0x86, 0x29, 0xd5, 0xca, 0x7b, 0x1d, 0x06, 0x82, 0x16, 0xd3, 0x4e, 0x0f, 0x92,
	0x76, 0x7b, 0x90, 0xf4, 0x7d, 0x57, 0x23, 0x33, 0xfa, 0xe4, 0xb7, 0xa4, 0xa0, 0x4c, 0xaa, 0x96,
	0x27, 0x92, 0x9e, 0x0b, 0x90, 0x88, 0xc2, 0x82, 0x11, 0x58, 0x80, 0xb1, 0x86, 0x2d, 0xe0, 0x20,
	0x26, 0x14, 0x67, 0x40, 0x96, 0x60, 0xbc, 0xc6, 0x54, 0x13, 0xc9, 0x8a, 0x29, 0x38, 0x22, 0x9b,
	0x30, 0x6e, 0x5a, 0xaa, 0x55, 0x37, 0xf1, 0x4c, 0x24, 0x23, 0xcf, 0xc4, 0x3d, 0xae, 0xa6, 0xa0,
	0x3a, 0xb9, 0x06, 0xe0, 0xa4, 0xba, 0x99, 0x57, 0x2d, 0x9e, 0xed, 0x83, 0x38, 0x13, 0xc3, 0x35,
	0x37, 0x2c, 0xe9, 0x02, 0x2c, 0x3a, 0x97, 0x0d, 0x6f, 0x66, 0x6f, 0xb1, 0xa6, 0xcb, 0xe6, 0xff,
	0x21, 0x86, 0x0d, 0xae, 0xc7, 0xe4, 0x84, 0x23, 0xc8, 0xd9, 0x5d, 0xd0, 0x52, 0x70, 0x15, 0xfa,
	0x6d, 0xf7, 0x1b, 0x5e, 0x5f, 0x8c, 0x15, 0xba, 0xa7, 0xdf, 0xf0, 0x56, 0xa1, 0x89, 0x5b, 0xac,
	0x69, 0x67, 0xef, 0xd1, 0xee, 0x3d, 0xcd, 0x4c, 0xf3, 0xf6, 0xa7, 0x7a, 0x27, 0x77, 0xd3, 0x30,
	0x66, 0xd8, 0xe3, 0xbe, 0xa9, 0xeb, 0xa8, 0x1d, 0x58, 0xe6, 0x26, 0x61, 0x12, 0x5d, 0xf2, 0xb2,
	0x36, 0xa6, 0xa0, 0x97, 0xbc, 0xee, 0x9e, 0x86, 0x39, 0xb7, 0xee, 0x6a, 0x3a, 0x6f, 0x8d, 0x18,
	0x16, 0x5e, 0xb7, 0x1e, 0xe7, 0x50, 0x2c, 0x7d, 0xe7, 0x9e, 0x9c, 0x10, 0x2f, 0x91, 0xc1, 0xac,
	0x67, 0xee, 0x21, 0x6b, 0xba, 0x09, 0x1b, 0x49, 0xa1, 0x3f, 0x4b, 0xc1, 0x63, 0xf3, 0x00, 0xab,
	0xea, 0x4b, 0xb7, 0xde, 0xf8, 0x11, 0xbf, 0x67, 0x14, 0xf9, 0xac, 0x1b, 0x1a, 0x11, 0x26, 0xca,
	0x28, 0x72, 0xcf, 0x8a, 0x3b, 0x3e, 0x94, 0x61, 0xf0, 0x2e, 0xc0, 0x70, 0xa7, 0x0e, 0x65, 0x24,
	0x6c, 0x02, 0x9c, 0x22, 0x59, 0x34, 0xea, 0xba, 0x85, 0x35, 0x12, 0xb8, 0x68, 0xdb, 0x96, 0x48,
	0xd7, 0x31, 0x97, 0xef, 0xf0, 0xf7, 0xa1, 0x2f, 0x97, 0x7b, 0x9e, 0x31, 0x64, 0x11, 0xc6, 0xf9,
	0xf3, 0x91, 0x62, 0x21, 0x1a, 0x7b, 0xc8, 0x9a, 0x39, 0x2a, 0x7d, 0x84, 0x79, 0xed, 0xdb, 0xc1,
	0xe3, 0x62, 0x36, 0xf0, 0xec, 0xc4, 0xe4, 0x5e, 0x0e, 0xbe, 0xaf, 0xdc, 0xa5, 0x39, 0x7d, 0xc7,
	0x50, 0xa6, 0xab, 0xfe, 0xe1, 0xc6, 0xee, 0x0c, 0x8c, 0x71, 0x03, 0xa4, 0x0e, 0xe3, 0xce, 0x4b,
	0x8c, 0x1c, 0x0b, 0x6c, 0xd0, 0xfb, 0xd4, 0x13, 0xa5, 0xfd, 0x54, 0x1c, 0x80, 0xd2, 0xf1, 0xcf,
	0x5e, 0xfd, 0xf1, 0xd5, 0x70, 0x82, 0x2c, 0xcb, 0xb4, 0x50, 0x2e, 0x30, 0x26, 0x87, 0xbd, 0xa7,
	0x49, 0x15, 0x46, 0xb2, 0xb9, 0x2c, 0x49, 0x84, 0x6d, 0xd8, 0x79, 0xf7, 0x89, 0xc9, 0xc8, 0x79,
	0xb4, 0xb6, 0xca, 0xad, 0x49, 0x24, 0x15, 0x6e, 0x8d, 0x6a, 0xd4, 0x94, 0x5b, 0x54, 0xa3, 0x6d,
	0x52, 0x81, 0x51, 0xbb, 0x91, 0x27, 0x51, 0x5b, 0x7a, 0x4e, 0xa6, 0xa2, 0x15, 0xd0, 0xa8, 0xc4,
	0x8d, 0x2e, 0x13, 0x31, 0xda, 0x28, 0xf9, 0x56, 0x80, 0xb9, 0xe0, 0xc3, 0x81, 0xbc, 0x11, 0xb5,
	0x75, 0xc8, 0x0b, 0x48, 0x3c, 0x3b, 0x98, 0x32, 0x62, 0xba, 0xca, 0x31, 0x6d, 0x92, 0x8b, 0xd1,
	0x98, 0xd6, 0x0a, 0xcd, 0xb5, 0xce, 0x3b, 0x49, 0x6e, 0x75, 0xbe, 0xdb, 0xe4, 0x6b, 0x01, 0xa0,
	0x73, 0xb9, 0x91, 0x13, 0x61, 0xb6, 0x7b, 0x5e, 0x14, 0xe2, 0xc9, 0x7e, 0x6a, 0x08, 0xee, 0x32,
	0x07, 0x77, 0x9e, 0xac, 0x87, 0x83, 0xf3, 0xf5, 0x45, 0x72, 0xab, 0xab, 0x75, 0x68, 0x93, 0x1f,
	0x05, 0x58, 0x08, 0xeb, 0x8e, 0x89, 0xbc, 0xbf, 0xed, 0x9e, 0xf7, 0x83, 0x78, 0x6e, 0xf0, 0x05,
	0x08, 0xfb, 0x2d, 0x0e, 0x7b, 0x8b, 0x5c, 0xea, 0x0b, 0xdb, 0xa6, 0x16, 0x5f, 0x23, 0x72, 0x0b,
	0x3f, 0xda, 0xe4, 0x99, 0x00, 0x47, 0x42, 0xba, 0x43, 0x92, 0xee, 0x8b, 0xa4, 0xab, 0x59, 0x16,
	0xe5, 0x81, 0xf5, 0x11, 0xf8, 0x9b, 0x1c, 0xf8, 0x25, 0x72, 0x61, 0x20, 0xe0, 0x4e, 0x83, 0x2d,
	0xb7, 0x9c, 0xff, 0x36, 0xf9, 0x41, 0x80, 0xf9, 0x9e, 0x86, 0x8a, 0x84, 0x1e, 0xc7, 0xa8, 0x1e,
	0x50, 0x5c, 0x1b, 0x50, 0x1b, 0x01, 0x5f, 0xe3, 0x80, 0x2f, 0x93, 0xcd, 0xd7, 0x3e, 0x20, 0xb2,
	0xd3, 0xd0, 0x7d, 0x21, 0x40, 0xcc, 0xbb, 0x01, 0xc8, 0xf1, 0xd0, 0xd4, 0x09, 0x74, 0x56, 0xe2,
	0x89, 0x3e, 0x5a, 0x88, 0xed, 0x22, 0xc7, 0x26, 0x93, 0xb5, 0x88, 0xcc, 0xe2, 0x0b, 0xd6, 0xec,
	0x9b, 0x49, 0x6e, 0x79, 0x9d, 0x5a, 0xdb, 0x2e, 0x00, 0xf3, 0x3d, 0xcd, 0x45, 0x38, 0x8b, 0x51,
	0x9d, 0x56, 0x38, 0x8b, 0x91, 0x1d, 0x8b, 0x74, 0x85, 0x23, 0xbd, 0x40, 0x36, 0xfa, 0x22, 0xb5,
	0xc3, 0xce, 0x9b, 0x33, 0xb9, 0xc5, 0xff, 0xda, 0xe4, 0x27, 0x01, 0x16, 0xc2, 0x2e, 0xe1, 0xf0,
	0x3c, 0xdb, 0xa7, 0x07, 0x09, 0xcf, 0xb3, 0xfd, 0xee, 0x77, 0xe9, 0x3a, 0xc7, 0x7d, 0x85, 0x6c,
	0x0d, 0x84, 0xdb, 0x6d, 0x68, 0xe4, 0x96, 0xfb, 0xd5, 0x26, 0x5f, 0x0a, 0x10, 0xf3, 0x2e, 0xbc,
	0xf0, 0xf0, 0x07, 0x2f, 0xe3, 0xf0, 0xf0, 0xf7, 0x5c, 0xb8, 0xd2, 0x16, 0x07, 0xb7, 0x41, 0xce,
	0x45, 0xdc, 0x67, 0x7c, 0x81, 0x1b, 0x7e, 0xfb, 0x40, 0xb6, 0x9c, 0x0b, 0xbd, 0x9d, 0x39, 0xfb,
	0x7c, 0x37, 0x21, 0xbc, 0xd8, 0x4d, 0x08, 0xbf, 0xef, 0x26, 0x84, 0x27, 0x7b, 0x89, 0xa1, 0x17,
	0x7b, 0x89, 0xa1, 0x5f, 0xf6, 0x12, 0x43, 0x1f, 0x12, 0xdc, 0xe3, 0x31, 0xdf, 0xc5, 0x6e, 0xa3,
	0xcc, 0xc2, 0x38, 0x7f, 0x25, 0x9c, 0xff, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xdd, 0x51, 0xec, 0x45,
	0x07, 0x17, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// Parameters queries the parameters of the module.
	Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
	// DID queries a DID document by its identifier
	DID(ctx context.Context, in *QueryDIDRequest, opts ...grpc.CallOption) (*QueryDIDResponse, error)
	// DIDs queries all DID documents with optional filtering
	DIDs(ctx context.Context, in *QueryDIDsRequest, opts ...grpc.CallOption) (*QueryDIDsResponse, error)
	// DIDs by controller queries all DIDs controlled by an address
	DIDsByController(ctx context.Context, in *QueryDIDsByControllerRequest, opts ...grpc.CallOption) (*QueryDIDsByControllerResponse, error)
	// Credential queries a verifiable credential by its identifier
	Credential(ctx context.Context, in *QueryCredentialRequest, opts ...grpc.CallOption) (*QueryCredentialResponse, error)
	// CredentialsBySubject queries all credentials for a given subject DID
	CredentialsBySubject(ctx context.Context, in *QueryCredentialsBySubjectRequest, opts ...grpc.CallOption) (*QueryCredentialsBySubjectResponse, error)
	// CredentialsByIssuer queries all credentials issued by a given address
	CredentialsByIssuer(ctx context.Context, in *QueryCredentialsByIssuerRequest, opts ...grpc.CallOption) (*QueryCredentialsByIssuerResponse, error)
	// IsCredentialValid checks if a credential is currently valid
	IsCredentialValid(ctx context.Context, in *QueryIsCredentialValidRequest, opts ...grpc.CallOption) (*QueryIsCredentialValidResponse, error)
	// DeviceKey queries a device's public key by device ID
	DeviceKey(ctx context.Context, in *QueryDeviceKeyRequest, opts ...grpc.CallOption) (*QueryDeviceKeyResponse, error)
	// DeviceKeysByOwner queries all device keys owned by an address
	DeviceKeysByOwner(ctx context.Context, in *QueryDeviceKeysByOwnerRequest, opts ...grpc.CallOption) (*QueryDeviceKeysByOwnerResponse, error)
	// DeviceKeysByLocation queries all device keys at a given location
	DeviceKeysByLocation(ctx context.Context, in *QueryDeviceKeysByLocationRequest, opts ...grpc.CallOption) (*QueryDeviceKeysByLocationResponse, error)
	// PublicKey queries a specific public key from a DID document
	PublicKey(ctx context.Context, in *QueryPublicKeyRequest, opts ...grpc.CallOption) (*QueryPublicKeyResponse, error)
}

type queryClient struct {
	cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) {
	out := new(QueryParamsResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Query/Params", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) DID(ctx context.Context, in *QueryDIDRequest, opts ...grpc.CallOption) (*QueryDIDResponse, error) {
	out := new(QueryDIDResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Query/DID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) DIDs(ctx context.Context, in *QueryDIDsRequest, opts ...grpc.CallOption) (*QueryDIDsResponse, error) {
	out := new(QueryDIDsResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Query/DIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) DIDsByController(ctx context.Context, in *QueryDIDsByControllerRequest, opts ...grpc.CallOption) (*QueryDIDsByControllerResponse, error) {
	out := new(QueryDIDsByControllerResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Query/DIDsByController", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Credential(ctx context.Context, in *QueryCredentialRequest, opts ...grpc.CallOption) (*QueryCredentialResponse, error) {
	out := new(QueryCredentialResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Query/Credential", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) CredentialsBySubject(ctx context.Context, in *QueryCredentialsBySubjectRequest, opts ...grpc.CallOption) (*QueryCredentialsBySubjectResponse, error) {
	out := new(QueryCredentialsBySubjectResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Query/CredentialsBySubject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) CredentialsByIssuer(ctx context.Context, in *QueryCredentialsByIssuerRequest, opts ...grpc.CallOption) (*QueryCredentialsByIssuerResponse, error) {
	out := new(QueryCredentialsByIssuerResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Query/CredentialsByIssuer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) IsCredentialValid(ctx context.Context, in *QueryIsCredentialValidRequest, opts ...grpc.CallOption) (*QueryIsCredentialValidResponse, error) {
	out := new(QueryIsCredentialValidResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Query/IsCredentialValid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) DeviceKey(ctx context.Context, in *QueryDeviceKeyRequest, opts ...grpc.CallOption) (*QueryDeviceKeyResponse, error) {
	out := new(QueryDeviceKeyResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Query/DeviceKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) DeviceKeysByOwner(ctx context.Context, in *QueryDeviceKeysByOwnerRequest, opts ...grpc.CallOption) (*QueryDeviceKeysByOwnerResponse, error) {
	out := new(QueryDeviceKeysByOwnerResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Query/DeviceKeysByOwner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) DeviceKeysByLocation(ctx context.Context, in *QueryDeviceKeysByLocationRequest, opts ...grpc.CallOption) (*QueryDeviceKeysByLocationResponse, error) {
	out := new(QueryDeviceKeysByLocationResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Query/DeviceKeysByLocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) PublicKey(ctx context.Context, in *QueryPublicKeyRequest, opts ...grpc.CallOption) (*QueryPublicKeyResponse, error) {
	out := new(QueryPublicKeyResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Query/PublicKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// Parameters queries the parameters of the module.
	Params(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
	// DID queries a DID document by its identifier
	DID(context.Context, *QueryDIDRequest) (*QueryDIDResponse, error)
	// DIDs queries all DID documents with optional filtering
	DIDs(context.Context, *QueryDIDsRequest) (*QueryDIDsResponse, error)
	// DIDs by controller queries all DIDs controlled by an address
	DIDsByController(context.Context, *QueryDIDsByControllerRequest) (*QueryDIDsByControllerResponse, error)
	// Credential queries a verifiable credential by its identifier
	Credential(context.Context, *QueryCredentialRequest) (*QueryCredentialResponse, error)
	// CredentialsBySubject queries all credentials for a given subject DID
	CredentialsBySubject(context.Context, *QueryCredentialsBySubjectRequest) (*QueryCredentialsBySubjectResponse, error)
	// CredentialsByIssuer queries all credentials issued by a given address
	CredentialsByIssuer(context.Context, *QueryCredentialsByIssuerRequest) (*QueryCredentialsByIssuerResponse, error)
	// IsCredentialValid checks if a credential is currently valid
	IsCredentialValid(context.Context, *QueryIsCredentialValidRequest) (*QueryIsCredentialValidResponse, error)
	// DeviceKey queries a device's public key by device ID
	DeviceKey(context.Context, *QueryDeviceKeyRequest) (*QueryDeviceKeyResponse, error)
	// DeviceKeysByOwner queries all device keys owned by an address
	DeviceKeysByOwner(context.Context, *QueryDeviceKeysByOwnerRequest) (*QueryDeviceKeysByOwnerResponse, error)
	// DeviceKeysByLocation queries all device keys at a given location
	DeviceKeysByLocation(context.Context, *QueryDeviceKeysByLocationRequest) (*QueryDeviceKeysByLocationResponse, error)
	// PublicKey queries a specific public key from a DID document
	PublicKey(context.Context, *QueryPublicKeyRequest) (*QueryPublicKeyResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) Params(ctx context.Context, req *QueryParamsRequest) (*QueryParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Params not implemented")
}
func (*UnimplementedQueryServer) DID(ctx context.Context, req *QueryDIDRequest) (*QueryDIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DID not implemented")
}
func (*UnimplementedQueryServer) DIDs(ctx context.Context, req *QueryDIDsRequest) (*QueryDIDsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DIDs not implemented")
}
func (*UnimplementedQueryServer) DIDsByController(ctx context.Context, req *QueryDIDsByControllerRequest) (*QueryDIDsByControllerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DIDsByController not implemented")
}
func (*UnimplementedQueryServer) Credential(ctx context.Context, req *QueryCredentialRequest) (*QueryCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Credential not implemented")
}
func (*UnimplementedQueryServer) CredentialsBySubject(ctx context.Context, req *QueryCredentialsBySubjectRequest) (*QueryCredentialsBySubjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CredentialsBySubject not implemented")
}
func (*UnimplementedQueryServer) CredentialsByIssuer(ctx context.Context, req *QueryCredentialsByIssuerRequest) (*QueryCredentialsByIssuerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CredentialsByIssuer not implemented")
}
func (*UnimplementedQueryServer) IsCredentialValid(ctx context.Context, req *QueryIsCredentialValidRequest) (*QueryIsCredentialValidResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsCredentialValid not implemented")
}
func (*UnimplementedQueryServer) DeviceKey(ctx context.Context, req *QueryDeviceKeyRequest) (*QueryDeviceKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeviceKey not implemented")
}
func (*UnimplementedQueryServer) DeviceKeysByOwner(ctx context.Context, req *QueryDeviceKeysByOwnerRequest) (*QueryDeviceKeysByOwnerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeviceKeysByOwner not implemented")
}
func (*UnimplementedQueryServer) DeviceKeysByLocation(ctx context.Context, req *QueryDeviceKeysByLocationRequest) (*QueryDeviceKeysByLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeviceKeysByLocation not implemented")
}
func (*UnimplementedQueryServer) PublicKey(ctx context.Context, req *QueryPublicKeyRequest) (*QueryPublicKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublicKey not implemented")
}

func RegisterQueryServer(s grpc1.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_Params_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Params(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Query/Params",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Params(ctx, req.(*QueryParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_DID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).DID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Query/DID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).DID(ctx, req.(*QueryDIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_DIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDIDsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).DIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Query/DIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).DIDs(ctx, req.(*QueryDIDsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_DIDsByController_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDIDsByControllerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).DIDsByController(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Query/DIDsByController",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).DIDsByController(ctx, req.(*QueryDIDsByControllerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Credential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Credential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Query/Credential",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Credential(ctx, req.(*QueryCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_CredentialsBySubject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCredentialsBySubjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).CredentialsBySubject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Query/CredentialsBySubject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).CredentialsBySubject(ctx, req.(*QueryCredentialsBySubjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_CredentialsByIssuer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCredentialsByIssuerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).CredentialsByIssuer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Query/CredentialsByIssuer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).CredentialsByIssuer(ctx, req.(*QueryCredentialsByIssuerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_IsCredentialValid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryIsCredentialValidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).IsCredentialValid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Query/IsCredentialValid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).IsCredentialValid(ctx, req.(*QueryIsCredentialValidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_DeviceKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDeviceKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).DeviceKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Query/DeviceKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).DeviceKey(ctx, req.(*QueryDeviceKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_DeviceKeysByOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDeviceKeysByOwnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).DeviceKeysByOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Query/DeviceKeysByOwner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).DeviceKeysByOwner(ctx, req.(*QueryDeviceKeysByOwnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_DeviceKeysByLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDeviceKeysByLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).DeviceKeysByLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Query/DeviceKeysByLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).DeviceKeysByLocation(ctx, req.(*QueryDeviceKeysByLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_PublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPublicKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).PublicKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Query/PublicKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).PublicKey(ctx, req.(*QueryPublicKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var Query_serviceDesc = _Query_serviceDesc
var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "acmain.iam.v1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Params",
			Handler:    _Query_Params_Handler,
		},
		{
			MethodName: "DID",
			Handler:    _Query_DID_Handler,
		},
		{
			MethodName: "DIDs",
			Handler:    _Query_DIDs_Handler,
		},
		{
			MethodName: "DIDsByController",
			Handler:    _Query_DIDsByController_Handler,
		},
		{
			MethodName: "Credential",
			Handler:    _Query_Credential_Handler,
		},
		{
			MethodName: "CredentialsBySubject",
			Handler:    _Query_CredentialsBySubject_Handler,
		},
		{
			MethodName: "CredentialsByIssuer",
			Handler:    _Query_CredentialsByIssuer_Handler,
		},
		{
			MethodName: "IsCredentialValid",
			Handler:    _Query_IsCredentialValid_Handler,
		},
		{
			MethodName: "DeviceKey",
			Handler:    _Query_DeviceKey_Handler,
		},
		{
			MethodName: "DeviceKeysByOwner",
			Handler:    _Query_DeviceKeysByOwner_Handler,
		},
		{
			MethodName: "DeviceKeysByLocation",
			Handler:    _Query_DeviceKeysByLocation_Handler,
		},
		{
			MethodName: "PublicKey",
			Handler:    _Query_PublicKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "acmain/iam/v1/query.proto",
}

func (m *QueryParamsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParamsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryDIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Did) > 0 {
		i -= len(m.Did)
		copy(dAtA[i:], m.Did)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Did)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DidDocument != nil {
		{
			size, err := m.DidDocument.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDIDsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDIDsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDIDsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeactivatedOnly {
		i--
		if m.DeactivatedOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.DidMethod != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.DidMethod))
		i--
		dAtA[i] = 0x10
	}
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDIDsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDIDsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDIDsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.DidDocuments) > 0 {
		for iNdEx := len(m.DidDocuments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DidDocuments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryDIDsByControllerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDIDsByControllerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDIDsByControllerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Controller) > 0 {
		i -= len(m.Controller)
		copy(dAtA[i:], m.Controller)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Controller)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDIDsByControllerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDIDsByControllerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDIDsByControllerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.DidDocuments) > 0 {
		for iNdEx := len(m.DidDocuments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DidDocuments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryCredentialRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryCredentialRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryCredentialRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CredentialId) > 0 {
		i -= len(m.CredentialId)
		copy(dAtA[i:], m.CredentialId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.CredentialId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryCredentialResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryCredentialResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryCredentialResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VerifiableCredential != nil {
		{
			size, err := m.VerifiableCredential.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryCredentialsBySubjectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryCredentialsBySubjectRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryCredentialsBySubjectRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IncludeExpired {
		i--
		if m.IncludeExpired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.CredentialType != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.CredentialType))
		i--
		dAtA[i] = 0x18
	}
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryCredentialsBySubjectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryCredentialsBySubjectResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryCredentialsBySubjectResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.VerifiableCredentials) > 0 {
		for iNdEx := len(m.VerifiableCredentials) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VerifiableCredentials[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryCredentialsByIssuerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryCredentialsByIssuerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryCredentialsByIssuerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CredentialType != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.CredentialType))
		i--
		dAtA[i] = 0x18
	}
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryCredentialsByIssuerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryCredentialsByIssuerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryCredentialsByIssuerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalIssued != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TotalIssued))
		i--
		dAtA[i] = 0x18
	}
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.VerifiableCredentials) > 0 {
		for iNdEx := len(m.VerifiableCredentials) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VerifiableCredentials[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryIsCredentialValidRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryIsCredentialValidRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryIsCredentialValidRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AtTimestamp != nil {
		n12, err12 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.AtTimestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.AtTimestamp):])
		if err12 != nil {
			return 0, err12
		}
		i -= n12
		i = encodeVarintQuery(dAtA, i, uint64(n12))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CredentialId) > 0 {
		i -= len(m.CredentialId)
		copy(dAtA[i:], m.CredentialId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.CredentialId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryIsCredentialValidResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryIsCredentialValidResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryIsCredentialValidResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiresAt != nil {
		n13, err13 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.ExpiresAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ExpiresAt):])
		if err13 != nil {
			return 0, err13
		}
		i -= n13
		i = encodeVarintQuery(dAtA, i, uint64(n13))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.Valid {
		i--
		if m.Valid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryDeviceKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDeviceKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDeviceKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDeviceKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDeviceKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDeviceKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeviceKey != nil {
		{
			size, err := m.DeviceKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDeviceKeysByOwnerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDeviceKeysByOwnerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDeviceKeysByOwnerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IncludeInactive {
		i--
		if m.IncludeInactive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.DeviceType) > 0 {
		i -= len(m.DeviceType)
		copy(dAtA[i:], m.DeviceType)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.DeviceType)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDeviceKeysByOwnerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDeviceKeysByOwnerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDeviceKeysByOwnerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeviceKeys) > 0 {
		for iNdEx := len(m.DeviceKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DeviceKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryDeviceKeysByLocationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDeviceKeysByLocationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDeviceKeysByLocationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IncludeInactive {
		i--
		if m.IncludeInactive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.DeviceType) > 0 {
		i -= len(m.DeviceType)
		copy(dAtA[i:], m.DeviceType)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.DeviceType)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDeviceKeysByLocationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDeviceKeysByLocationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDeviceKeysByLocationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalCount != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TotalCount))
		i--
		dAtA[i] = 0x18
	}
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeviceKeys) > 0 {
		for iNdEx := len(m.DeviceKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DeviceKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryPublicKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPublicKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPublicKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KeyId) > 0 {
		i -= len(m.KeyId)
		copy(dAtA[i:], m.KeyId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.KeyId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Did) > 0 {
		i -= len(m.Did)
		copy(dAtA[i:], m.Did)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Did)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryPublicKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPublicKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPublicKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PublicKeyInfo != nil {
		{
			size, err := m.PublicKeyInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueryParamsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryDIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Did)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DidDocument != nil {
		l = m.DidDocument.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDIDsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.DidMethod != 0 {
		n += 1 + sovQuery(uint64(m.DidMethod))
	}
	if m.DeactivatedOnly {
		n += 2
	}
	return n
}

func (m *QueryDIDsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DidDocuments) > 0 {
		for _, e := range m.DidDocuments {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDIDsByControllerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Controller)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDIDsByControllerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DidDocuments) > 0 {
		for _, e := range m.DidDocuments {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryCredentialRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CredentialId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryCredentialResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VerifiableCredential != nil {
		l = m.VerifiableCredential.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryCredentialsBySubjectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.CredentialType != 0 {
		n += 1 + sovQuery(uint64(m.CredentialType))
	}
	if m.IncludeExpired {
		n += 2
	}
	return n
}

func (m *QueryCredentialsBySubjectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VerifiableCredentials) > 0 {
		for _, e := range m.VerifiableCredentials {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryCredentialsByIssuerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.CredentialType != 0 {
		n += 1 + sovQuery(uint64(m.CredentialType))
	}
	return n
}

func (m *QueryCredentialsByIssuerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VerifiableCredentials) > 0 {
		for _, e := range m.VerifiableCredentials {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.TotalIssued != 0 {
		n += 1 + sovQuery(uint64(m.TotalIssued))
	}
	return n
}

func (m *QueryIsCredentialValidRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CredentialId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.AtTimestamp != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.AtTimestamp)
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryIsCredentialValidResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Valid {
		n += 2
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovQuery(uint64(m.Status))
	}
	if m.ExpiresAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ExpiresAt)
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDeviceKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDeviceKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeviceKey != nil {
		l = m.DeviceKey.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDeviceKeysByOwnerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.DeviceType)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.IncludeInactive {
		n += 2
	}
	return n
}

func (m *QueryDeviceKeysByOwnerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DeviceKeys) > 0 {
		for _, e := range m.DeviceKeys {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDeviceKeysByLocationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.DeviceType)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.IncludeInactive {
		n += 2
	}
	return n
}

func (m *QueryDeviceKeysByLocationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DeviceKeys) > 0 {
		for _, e := range m.DeviceKeys {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.TotalCount != 0 {
		n += 1 + sovQuery(uint64(m.TotalCount))
	}
	return n
}

func (m *QueryPublicKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Did)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.KeyId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryPublicKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublicKeyInfo != nil {
		l = m.PublicKeyInfo.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryParamsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParamsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Did = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DidDocument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DidDocument == nil {
				m.DidDocument = &DIDDocument{}
			}
			if err := m.DidDocument.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDIDsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDIDsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDIDsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DidMethod", wireType)
			}
			m.DidMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DidMethod |= DIDMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeactivatedOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeactivatedOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDIDsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDIDsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDIDsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DidDocuments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DidDocuments = append(m.DidDocuments, DIDDocument{})
			if err := m.DidDocuments[len(m.DidDocuments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDIDsByControllerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDIDsByControllerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDIDsByControllerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDIDsByControllerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDIDsByControllerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDIDsByControllerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DidDocuments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DidDocuments = append(m.DidDocuments, DIDDocument{})
			if err := m.DidDocuments[len(m.DidDocuments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryCredentialRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryCredentialRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryCredentialRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryCredentialResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryCredentialResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryCredentialResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifiableCredential", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VerifiableCredential == nil {
				m.VerifiableCredential = &VerifiableCredential{}
			}
			if err := m.VerifiableCredential.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryCredentialsBySubjectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryCredentialsBySubjectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryCredentialsBySubjectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialType", wireType)
			}
			m.CredentialType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CredentialType |= CredentialType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeExpired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeExpired = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryCredentialsBySubjectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryCredentialsBySubjectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryCredentialsBySubjectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifiableCredentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifiableCredentials = append(m.VerifiableCredentials, VerifiableCredential{})
			if err := m.VerifiableCredentials[len(m.VerifiableCredentials)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryCredentialsByIssuerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryCredentialsByIssuerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryCredentialsByIssuerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialType", wireType)
			}
			m.CredentialType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CredentialType |= CredentialType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryCredentialsByIssuerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryCredentialsByIssuerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryCredentialsByIssuerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifiableCredentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifiableCredentials = append(m.VerifiableCredentials, VerifiableCredential{})
			if err := m.VerifiableCredentials[len(m.VerifiableCredentials)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalIssued", wireType)
			}
			m.TotalIssued = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalIssued |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryIsCredentialValidRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryIsCredentialValidRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryIsCredentialValidRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AtTimestamp == nil {
				m.AtTimestamp = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.AtTimestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryIsCredentialValidResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryIsCredentialValidResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryIsCredentialValidResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Valid = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= CredentialStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiresAt == nil {
				m.ExpiresAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.ExpiresAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDeviceKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDeviceKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDeviceKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDeviceKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDeviceKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDeviceKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceKey == nil {
				m.DeviceKey = &DeviceKey{}
			}
			if err := m.DeviceKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDeviceKeysByOwnerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDeviceKeysByOwnerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDeviceKeysByOwnerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeInactive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeInactive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDeviceKeysByOwnerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDeviceKeysByOwnerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDeviceKeysByOwnerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceKeys = append(m.DeviceKeys, DeviceKey{})
			if err := m.DeviceKeys[len(m.DeviceKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDeviceKeysByLocationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDeviceKeysByLocationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDeviceKeysByLocationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeInactive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeInactive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDeviceKeysByLocationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDeviceKeysByLocationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDeviceKeysByLocationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceKeys = append(m.DeviceKeys, DeviceKey{})
			if err := m.DeviceKeys[len(m.DeviceKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPublicKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPublicKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPublicKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Did = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPublicKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPublicKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPublicKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicKeyInfo == nil {
				m.PublicKeyInfo = &PublicKeyInfo{}
			}
			if err := m.PublicKeyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
