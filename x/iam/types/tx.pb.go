// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: acmain/iam/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgUpdateParams is the Msg/UpdateParams request type.
type MsgUpdateParams struct {
	// authority is the address that controls the module (defaults to x/gov unless overwritten).
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// params defines the module parameters to update.
	//
	// NOTE: All parameters must be supplied.
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{0}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateParams) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// MsgUpdateParamsResponse defines the response structure for executing a
// MsgUpdateParams message.
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{1}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

// MsgRegisterDID registers a new Decentralized Identifier with a DID document
type MsgRegisterDID struct {
	// controller is the Cosmos address that will control this DID
	Controller string `protobuf:"bytes,1,opt,name=controller,proto3" json:"controller,omitempty"`
	// did is the full DID string (e.g., "did:acmain:cosmos1abcdef...")
	Did string `protobuf:"bytes,2,opt,name=did,proto3" json:"did,omitempty"`
	// did_method specifies which DID method is being used
	DidMethod DIDMethod `protobuf:"varint,3,opt,name=did_method,json=didMethod,proto3,enum=acmain.iam.v1.DIDMethod" json:"did_method,omitempty"`
	// public_key is the initial public key for this DID
	PublicKey []byte `protobuf:"bytes,4,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// key_type is the cryptographic algorithm
	KeyType KeyType `protobuf:"varint,5,opt,name=key_type,json=keyType,proto3,enum=acmain.iam.v1.KeyType" json:"key_type,omitempty"`
	// service_endpoints optional service endpoints (e.g., API, website)
	ServiceEndpoints []ServiceEndpoint `protobuf:"bytes,6,rep,name=service_endpoints,json=serviceEndpoints,proto3" json:"service_endpoints"`
	// also_known_as optional alternative identifiers
	AlsoKnownAs []string `protobuf:"bytes,7,rep,name=also_known_as,json=alsoKnownAs,proto3" json:"also_known_as,omitempty"`
	// metadata stores additional attributes (e.g., "device_type": "smart_lock")
	Metadata map[string]string `protobuf:"bytes,8,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *MsgRegisterDID) Reset()         { *m = MsgRegisterDID{} }
func (m *MsgRegisterDID) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterDID) ProtoMessage()    {}
func (*MsgRegisterDID) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{2}
}
func (m *MsgRegisterDID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterDID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterDID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterDID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterDID.Merge(m, src)
}
func (m *MsgRegisterDID) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterDID) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterDID.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterDID proto.InternalMessageInfo

func (m *MsgRegisterDID) GetController() string {
	if m != nil {
		return m.Controller
	}
	return ""
}

func (m *MsgRegisterDID) GetDid() string {
	if m != nil {
		return m.Did
	}
	return ""
}

func (m *MsgRegisterDID) GetDidMethod() DIDMethod {
	if m != nil {
		return m.DidMethod
	}
	return DID_METHOD_UNSPECIFIED
}

func (m *MsgRegisterDID) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *MsgRegisterDID) GetKeyType() KeyType {
	if m != nil {
		return m.KeyType
	}
	return KEY_TYPE_UNSPECIFIED
}

func (m *MsgRegisterDID) GetServiceEndpoints() []ServiceEndpoint {
	if m != nil {
		return m.ServiceEndpoints
	}
	return nil
}

func (m *MsgRegisterDID) GetAlsoKnownAs() []string {
	if m != nil {
		return m.AlsoKnownAs
	}
	return nil
}

func (m *MsgRegisterDID) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// MsgRegisterDIDResponse defines the response for RegisterDID
type MsgRegisterDIDResponse struct {
	// did_document is the created DID document
	DidDocument *DIDDocument `protobuf:"bytes,1,opt,name=did_document,json=didDocument,proto3" json:"did_document,omitempty"`
}

func (m *MsgRegisterDIDResponse) Reset()         { *m = MsgRegisterDIDResponse{} }
func (m *MsgRegisterDIDResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterDIDResponse) ProtoMessage()    {}
func (*MsgRegisterDIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{3}
}
func (m *MsgRegisterDIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterDIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterDIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterDIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterDIDResponse.Merge(m, src)
}
func (m *MsgRegisterDIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterDIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterDIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterDIDResponse proto.InternalMessageInfo

func (m *MsgRegisterDIDResponse) GetDidDocument() *DIDDocument {
	if m != nil {
		return m.DidDocument
	}
	return nil
}

// MsgUpdateDIDDocument updates an existing DID document
type MsgUpdateDIDDocument struct {
	// controller is the address authorized to update the DID
	Controller string `protobuf:"bytes,1,opt,name=controller,proto3" json:"controller,omitempty"`
	// did is the DID to update
	Did string `protobuf:"bytes,2,opt,name=did,proto3" json:"did,omitempty"`
	// service_endpoints replaces existing service endpoints
	ServiceEndpoints []ServiceEndpoint `protobuf:"bytes,3,rep,name=service_endpoints,json=serviceEndpoints,proto3" json:"service_endpoints"`
	// also_known_as replaces existing alternative identifiers
	AlsoKnownAs []string `protobuf:"bytes,4,rep,name=also_known_as,json=alsoKnownAs,proto3" json:"also_known_as,omitempty"`
	// metadata updates (merged with existing)
	Metadata map[string]string `protobuf:"bytes,5,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *MsgUpdateDIDDocument) Reset()         { *m = MsgUpdateDIDDocument{} }
func (m *MsgUpdateDIDDocument) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDIDDocument) ProtoMessage()    {}
func (*MsgUpdateDIDDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{4}
}
func (m *MsgUpdateDIDDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDIDDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDIDDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDIDDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDIDDocument.Merge(m, src)
}
func (m *MsgUpdateDIDDocument) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDIDDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDIDDocument.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDIDDocument proto.InternalMessageInfo

func (m *MsgUpdateDIDDocument) GetController() string {
	if m != nil {
		return m.Controller
	}
	return ""
}

func (m *MsgUpdateDIDDocument) GetDid() string {
	if m != nil {
		return m.Did
	}
	return ""
}

func (m *MsgUpdateDIDDocument) GetServiceEndpoints() []ServiceEndpoint {
	if m != nil {
		return m.ServiceEndpoints
	}
	return nil
}

func (m *MsgUpdateDIDDocument) GetAlsoKnownAs() []string {
	if m != nil {
		return m.AlsoKnownAs
	}
	return nil
}

func (m *MsgUpdateDIDDocument) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// MsgUpdateDIDDocumentResponse defines the response for UpdateDIDDocument
type MsgUpdateDIDDocumentResponse struct {
	// did_document is the updated DID document
	DidDocument *DIDDocument `protobuf:"bytes,1,opt,name=did_document,json=didDocument,proto3" json:"did_document,omitempty"`
}

func (m *MsgUpdateDIDDocumentResponse) Reset()         { *m = MsgUpdateDIDDocumentResponse{} }
func (m *MsgUpdateDIDDocumentResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDIDDocumentResponse) ProtoMessage()    {}
func (*MsgUpdateDIDDocumentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{5}
}
func (m *MsgUpdateDIDDocumentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDIDDocumentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDIDDocumentResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDIDDocumentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDIDDocumentResponse.Merge(m, src)
}
func (m *MsgUpdateDIDDocumentResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDIDDocumentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDIDDocumentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDIDDocumentResponse proto.InternalMessageInfo

func (m *MsgUpdateDIDDocumentResponse) GetDidDocument() *DIDDocument {
	if m != nil {
		return m.DidDocument
	}
	return nil
}

// MsgDeactivateDID deactivates a DID, preventing further modifications
type MsgDeactivateDID struct {
	// controller is the address authorized to deactivate the DID
	Controller string `protobuf:"bytes,1,opt,name=controller,proto3" json:"controller,omitempty"`
	// did is the DID to deactivate
	Did string `protobuf:"bytes,2,opt,name=did,proto3" json:"did,omitempty"`
}

func (m *MsgDeactivateDID) Reset()         { *m = MsgDeactivateDID{} }
func (m *MsgDeactivateDID) String() string { return proto.CompactTextString(m) }
func (*MsgDeactivateDID) ProtoMessage()    {}
func (*MsgDeactivateDID) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{6}
}
func (m *MsgDeactivateDID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeactivateDID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeactivateDID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeactivateDID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeactivateDID.Merge(m, src)
}
func (m *MsgDeactivateDID) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeactivateDID) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeactivateDID.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeactivateDID proto.InternalMessageInfo

func (m *MsgDeactivateDID) GetController() string {
	if m != nil {
		return m.Controller
	}
	return ""
}

func (m *MsgDeactivateDID) GetDid() string {
	if m != nil {
		return m.Did
	}
	return ""
}

// MsgDeactivateDIDResponse defines the response for DeactivateDID
type MsgDeactivateDIDResponse struct {
}

func (m *MsgDeactivateDIDResponse) Reset()         { *m = MsgDeactivateDIDResponse{} }
func (m *MsgDeactivateDIDResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDeactivateDIDResponse) ProtoMessage()    {}
func (*MsgDeactivateDIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{7}
}
func (m *MsgDeactivateDIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeactivateDIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeactivateDIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeactivateDIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeactivateDIDResponse.Merge(m, src)
}
func (m *MsgDeactivateDIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeactivateDIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeactivateDIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeactivateDIDResponse proto.InternalMessageInfo

// MsgAddPublicKey adds a new public key to a DID document
type MsgAddPublicKey struct {
	// controller is the address authorized to add keys
	Controller string `protobuf:"bytes,1,opt,name=controller,proto3" json:"controller,omitempty"`
	// did is the DID to which the key is added
	Did string `protobuf:"bytes,2,opt,name=did,proto3" json:"did,omitempty"`
	// key_id is the unique identifier for this key within the DID
	KeyId string `protobuf:"bytes,3,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// public_key is the key material
	PublicKey []byte `protobuf:"bytes,4,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// key_type is the cryptographic algorithm
	KeyType KeyType `protobuf:"varint,5,opt,name=key_type,json=keyType,proto3,enum=acmain.iam.v1.KeyType" json:"key_type,omitempty"`
	// purpose describes the key's intended purpose (e.g., "authentication", "assertionMethod")
	Purpose string `protobuf:"bytes,6,opt,name=purpose,proto3" json:"purpose,omitempty"`
}

func (m *MsgAddPublicKey) Reset()         { *m = MsgAddPublicKey{} }
func (m *MsgAddPublicKey) String() string { return proto.CompactTextString(m) }
func (*MsgAddPublicKey) ProtoMessage()    {}
func (*MsgAddPublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{8}
}
func (m *MsgAddPublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddPublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddPublicKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddPublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddPublicKey.Merge(m, src)
}
func (m *MsgAddPublicKey) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddPublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddPublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddPublicKey proto.InternalMessageInfo

func (m *MsgAddPublicKey) GetController() string {
	if m != nil {
		return m.Controller
	}
	return ""
}

func (m *MsgAddPublicKey) GetDid() string {
	if m != nil {
		return m.Did
	}
	return ""
}

func (m *MsgAddPublicKey) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *MsgAddPublicKey) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *MsgAddPublicKey) GetKeyType() KeyType {
	if m != nil {
		return m.KeyType
	}
	return KEY_TYPE_UNSPECIFIED
}

func (m *MsgAddPublicKey) GetPurpose() string {
	if m != nil {
		return m.Purpose
	}
	return ""
}

// MsgAddPublicKeyResponse defines the response for AddPublicKey
type MsgAddPublicKeyResponse struct {
	// public_key_info is the added key information
	PublicKeyInfo *PublicKeyInfo `protobuf:"bytes,1,opt,name=public_key_info,json=publicKeyInfo,proto3" json:"public_key_info,omitempty"`
}

func (m *MsgAddPublicKeyResponse) Reset()         { *m = MsgAddPublicKeyResponse{} }
func (m *MsgAddPublicKeyResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAddPublicKeyResponse) ProtoMessage()    {}
func (*MsgAddPublicKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{9}
}
func (m *MsgAddPublicKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddPublicKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddPublicKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddPublicKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddPublicKeyResponse.Merge(m, src)
}
func (m *MsgAddPublicKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddPublicKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddPublicKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddPublicKeyResponse proto.InternalMessageInfo

func (m *MsgAddPublicKeyResponse) GetPublicKeyInfo() *PublicKeyInfo {
	if m != nil {
		return m.PublicKeyInfo
	}
	return nil
}

// MsgRevokePublicKey revokes a public key from a DID document
type MsgRevokePublicKey struct {
	// controller is the address authorized to revoke keys
	Controller string `protobuf:"bytes,1,opt,name=controller,proto3" json:"controller,omitempty"`
	// did is the DID from which the key is revoked
	Did string `protobuf:"bytes,2,opt,name=did,proto3" json:"did,omitempty"`
	// key_id is the identifier of the key to revoke
	KeyId string `protobuf:"bytes,3,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *MsgRevokePublicKey) Reset()         { *m = MsgRevokePublicKey{} }
func (m *MsgRevokePublicKey) String() string { return proto.CompactTextString(m) }
func (*MsgRevokePublicKey) ProtoMessage()    {}
func (*MsgRevokePublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{10}
}
func (m *MsgRevokePublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevokePublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevokePublicKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevokePublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevokePublicKey.Merge(m, src)
}
func (m *MsgRevokePublicKey) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevokePublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevokePublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevokePublicKey proto.InternalMessageInfo

func (m *MsgRevokePublicKey) GetController() string {
	if m != nil {
		return m.Controller
	}
	return ""
}

func (m *MsgRevokePublicKey) GetDid() string {
	if m != nil {
		return m.Did
	}
	return ""
}

func (m *MsgRevokePublicKey) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

// MsgRevokePublicKeyResponse defines the response for RevokePublicKey
type MsgRevokePublicKeyResponse struct {
}

func (m *MsgRevokePublicKeyResponse) Reset()         { *m = MsgRevokePublicKeyResponse{} }
func (m *MsgRevokePublicKeyResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRevokePublicKeyResponse) ProtoMessage()    {}
func (*MsgRevokePublicKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{11}
}
func (m *MsgRevokePublicKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevokePublicKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevokePublicKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevokePublicKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevokePublicKeyResponse.Merge(m, src)
}
func (m *MsgRevokePublicKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevokePublicKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevokePublicKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevokePublicKeyResponse proto.InternalMessageInfo

// MsgIssueCredential issues a new Verifiable Credential
type MsgIssueCredential struct {
	// issuer is the Cosmos address issuing the credential
	Issuer string `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// subject is the DID of the credential subject
	Subject string `protobuf:"bytes,2,opt,name=subject,proto3" json:"subject,omitempty"`
	// credential_type is the semantic type of the credential
	CredentialType CredentialType `protobuf:"varint,3,opt,name=credential_type,json=credentialType,proto3,enum=acmain.iam.v1.CredentialType" json:"credential_type,omitempty"`
	// claims are the credential attributes (key-value pairs)
	// e.g., "role": "engineer", "department": "platform", "clearance": "level-2"
	Claims map[string]string `protobuf:"bytes,4,rep,name=claims,proto3" json:"claims,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// valid_from is the earliest time the credential is valid (optional)
	ValidFrom *time.Time `protobuf:"bytes,5,opt,name=valid_from,json=validFrom,proto3,stdtime" json:"valid_from,omitempty"`
	// valid_until is the expiration time of the credential
	ValidUntil *time.Time `protobuf:"bytes,6,opt,name=valid_until,json=validUntil,proto3,stdtime" json:"valid_until,omitempty"`
	// metadata stores issuer-specific attributes
	Metadata map[string]string `protobuf:"bytes,7,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// refresh_service optional service endpoint for credential renewal
	RefreshService string `protobuf:"bytes,8,opt,name=refresh_service,json=refreshService,proto3" json:"refresh_service,omitempty"`
	// signature is the issuer's signature over the canonical credential data
	// This proves the issuer authorized the credential issuance
	Signature []byte `protobuf:"bytes,9,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *MsgIssueCredential) Reset()         { *m = MsgIssueCredential{} }
func (m *MsgIssueCredential) String() string { return proto.CompactTextString(m) }
func (*MsgIssueCredential) ProtoMessage()    {}
func (*MsgIssueCredential) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{12}
}
func (m *MsgIssueCredential) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgIssueCredential) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgIssueCredential.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgIssueCredential) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgIssueCredential.Merge(m, src)
}
func (m *MsgIssueCredential) XXX_Size() int {
	return m.Size()
}
func (m *MsgIssueCredential) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgIssueCredential.DiscardUnknown(m)
}

var xxx_messageInfo_MsgIssueCredential proto.InternalMessageInfo

func (m *MsgIssueCredential) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *MsgIssueCredential) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *MsgIssueCredential) GetCredentialType() CredentialType {
	if m != nil {
		return m.CredentialType
	}
	return CREDENTIAL_TYPE_UNSPECIFIED
}

func (m *MsgIssueCredential) GetClaims() map[string]string {
	if m != nil {
		return m.Claims
	}
	return nil
}

func (m *MsgIssueCredential) GetValidFrom() *time.Time {
	if m != nil {
		return m.ValidFrom
	}
	return nil
}

func (m *MsgIssueCredential) GetValidUntil() *time.Time {
	if m != nil {
		return m.ValidUntil
	}
	return nil
}

func (m *MsgIssueCredential) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *MsgIssueCredential) GetRefreshService() string {
	if m != nil {
		return m.RefreshService
	}
	return ""
}

func (m *MsgIssueCredential) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// MsgIssueCredentialResponse defines the response for IssueCredential
type MsgIssueCredentialResponse struct {
	// credential_id is the unique identifier of the issued credential
	CredentialId string `protobuf:"bytes,1,opt,name=credential_id,json=credentialId,proto3" json:"credential_id,omitempty"`
	// verifiable_credential is the complete credential
	VerifiableCredential *VerifiableCredential `protobuf:"bytes,2,opt,name=verifiable_credential,json=verifiableCredential,proto3" json:"verifiable_credential,omitempty"`
}

func (m *MsgIssueCredentialResponse) Reset()         { *m = MsgIssueCredentialResponse{} }
func (m *MsgIssueCredentialResponse) String() string { return proto.CompactTextString(m) }
func (*MsgIssueCredentialResponse) ProtoMessage()    {}
func (*MsgIssueCredentialResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{13}
}
func (m *MsgIssueCredentialResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgIssueCredentialResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgIssueCredentialResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgIssueCredentialResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgIssueCredentialResponse.Merge(m, src)
}
func (m *MsgIssueCredentialResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgIssueCredentialResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgIssueCredentialResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgIssueCredentialResponse proto.InternalMessageInfo

func (m *MsgIssueCredentialResponse) GetCredentialId() string {
	if m != nil {
		return m.CredentialId
	}
	return ""
}

func (m *MsgIssueCredentialResponse) GetVerifiableCredential() *VerifiableCredential {
	if m != nil {
		return m.VerifiableCredential
	}
	return nil
}

// MsgRevokeCredential revokes a previously issued Verifiable Credential
type MsgRevokeCredential struct {
	// issuer is the address that issued the credential (must match original issuer)
	Issuer string `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// credential_id is the unique identifier of the credential to revoke
	CredentialId string `protobuf:"bytes,2,opt,name=credential_id,json=credentialId,proto3" json:"credential_id,omitempty"`
	// revocation_reason describes why the credential was revoked
	RevocationReason string `protobuf:"bytes,3,opt,name=revocation_reason,json=revocationReason,proto3" json:"revocation_reason,omitempty"`
}

func (m *MsgRevokeCredential) Reset()         { *m = MsgRevokeCredential{} }
func (m *MsgRevokeCredential) String() string { return proto.CompactTextString(m) }
func (*MsgRevokeCredential) ProtoMessage()    {}
func (*MsgRevokeCredential) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{14}
}
func (m *MsgRevokeCredential) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevokeCredential) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevokeCredential.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevokeCredential) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevokeCredential.Merge(m, src)
}
func (m *MsgRevokeCredential) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevokeCredential) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevokeCredential.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevokeCredential proto.InternalMessageInfo

func (m *MsgRevokeCredential) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *MsgRevokeCredential) GetCredentialId() string {
	if m != nil {
		return m.CredentialId
	}
	return ""
}

func (m *MsgRevokeCredential) GetRevocationReason() string {
	if m != nil {
		return m.RevocationReason
	}
	return ""
}

// MsgRevokeCredentialResponse defines the response for RevokeCredential
type MsgRevokeCredentialResponse struct {
}

func (m *MsgRevokeCredentialResponse) Reset()         { *m = MsgRevokeCredentialResponse{} }
func (m *MsgRevokeCredentialResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRevokeCredentialResponse) ProtoMessage()    {}
func (*MsgRevokeCredentialResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{15}
}
func (m *MsgRevokeCredentialResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevokeCredentialResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevokeCredentialResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevokeCredentialResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevokeCredentialResponse.Merge(m, src)
}
func (m *MsgRevokeCredentialResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevokeCredentialResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevokeCredentialResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevokeCredentialResponse proto.InternalMessageInfo

// MsgSuspendCredential temporarily suspends a Verifiable Credential
type MsgSuspendCredential struct {
	// issuer is the address that issued the credential
	Issuer string `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// credential_id is the unique identifier of the credential to suspend
	CredentialId string `protobuf:"bytes,2,opt,name=credential_id,json=credentialId,proto3" json:"credential_id,omitempty"`
	// suspension_reason describes why the credential is suspended
	SuspensionReason string `protobuf:"bytes,3,opt,name=suspension_reason,json=suspensionReason,proto3" json:"suspension_reason,omitempty"`
}

func (m *MsgSuspendCredential) Reset()         { *m = MsgSuspendCredential{} }
func (m *MsgSuspendCredential) String() string { return proto.CompactTextString(m) }
func (*MsgSuspendCredential) ProtoMessage()    {}
func (*MsgSuspendCredential) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{16}
}
func (m *MsgSuspendCredential) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSuspendCredential) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSuspendCredential.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSuspendCredential) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSuspendCredential.Merge(m, src)
}
func (m *MsgSuspendCredential) XXX_Size() int {
	return m.Size()
}
func (m *MsgSuspendCredential) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSuspendCredential.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSuspendCredential proto.InternalMessageInfo

func (m *MsgSuspendCredential) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *MsgSuspendCredential) GetCredentialId() string {
	if m != nil {
		return m.CredentialId
	}
	return ""
}

func (m *MsgSuspendCredential) GetSuspensionReason() string {
	if m != nil {
		return m.SuspensionReason
	}
	return ""
}

// MsgSuspendCredentialResponse defines the response for SuspendCredential
type MsgSuspendCredentialResponse struct {
}

func (m *MsgSuspendCredentialResponse) Reset()         { *m = MsgSuspendCredentialResponse{} }
func (m *MsgSuspendCredentialResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSuspendCredentialResponse) ProtoMessage()    {}
func (*MsgSuspendCredentialResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{17}
}
func (m *MsgSuspendCredentialResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSuspendCredentialResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSuspendCredentialResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSuspendCredentialResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSuspendCredentialResponse.Merge(m, src)
}
func (m *MsgSuspendCredentialResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSuspendCredentialResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSuspendCredentialResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSuspendCredentialResponse proto.InternalMessageInfo

// MsgResumeCredential resumes a previously suspended Verifiable Credential
type MsgResumeCredential struct {
	// issuer is the address that issued the credential
	Issuer string `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// credential_id is the unique identifier of the credential to resume
	CredentialId string `protobuf:"bytes,2,opt,name=credential_id,json=credentialId,proto3" json:"credential_id,omitempty"`
}

func (m *MsgResumeCredential) Reset()         { *m = MsgResumeCredential{} }
func (m *MsgResumeCredential) String() string { return proto.CompactTextString(m) }
func (*MsgResumeCredential) ProtoMessage()    {}
func (*MsgResumeCredential) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{18}
}
func (m *MsgResumeCredential) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgResumeCredential) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgResumeCredential.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgResumeCredential) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgResumeCredential.Merge(m, src)
}
func (m *MsgResumeCredential) XXX_Size() int {
	return m.Size()
}
func (m *MsgResumeCredential) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgResumeCredential.DiscardUnknown(m)
}

var xxx_messageInfo_MsgResumeCredential proto.InternalMessageInfo

func (m *MsgResumeCredential) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *MsgResumeCredential) GetCredentialId() string {
	if m != nil {
		return m.CredentialId
	}
	return ""
}

// MsgResumeCredentialResponse defines the response for ResumeCredential
type MsgResumeCredentialResponse struct {
}

func (m *MsgResumeCredentialResponse) Reset()         { *m = MsgResumeCredentialResponse{} }
func (m *MsgResumeCredentialResponse) String() string { return proto.CompactTextString(m) }
func (*MsgResumeCredentialResponse) ProtoMessage()    {}
func (*MsgResumeCredentialResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{19}
}
func (m *MsgResumeCredentialResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgResumeCredentialResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgResumeCredentialResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgResumeCredentialResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgResumeCredentialResponse.Merge(m, src)
}
func (m *MsgResumeCredentialResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgResumeCredentialResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgResumeCredentialResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgResumeCredentialResponse proto.InternalMessageInfo

// MsgRegisterDeviceKey registers an IoT device's public key
type MsgRegisterDeviceKey struct {
	// owner is the Cosmos address that owns/registers the device
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// device_id is the unique identifier for the IoT device
	DeviceId string `protobuf:"bytes,2,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	// public_key is the device's public key
	PublicKey []byte `protobuf:"bytes,3,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// key_type is the cryptographic algorithm
	KeyType KeyType `protobuf:"varint,4,opt,name=key_type,json=keyType,proto3,enum=acmain.iam.v1.KeyType" json:"key_type,omitempty"`
	// device_type describes the device category (e.g., "smart_lock", "sensor", "witness_node")
	DeviceType string `protobuf:"bytes,5,opt,name=device_type,json=deviceType,proto3" json:"device_type,omitempty"`
	// location is where the device is physically located (e.g., building_id, floor, zone)
	Location string `protobuf:"bytes,6,opt,name=location,proto3" json:"location,omitempty"`
	// metadata stores device-specific attributes
	Metadata map[string]string `protobuf:"bytes,7,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *MsgRegisterDeviceKey) Reset()         { *m = MsgRegisterDeviceKey{} }
func (m *MsgRegisterDeviceKey) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterDeviceKey) ProtoMessage()    {}
func (*MsgRegisterDeviceKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{20}
}
func (m *MsgRegisterDeviceKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterDeviceKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterDeviceKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterDeviceKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterDeviceKey.Merge(m, src)
}
func (m *MsgRegisterDeviceKey) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterDeviceKey) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterDeviceKey.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterDeviceKey proto.InternalMessageInfo

func (m *MsgRegisterDeviceKey) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgRegisterDeviceKey) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *MsgRegisterDeviceKey) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *MsgRegisterDeviceKey) GetKeyType() KeyType {
	if m != nil {
		return m.KeyType
	}
	return KEY_TYPE_UNSPECIFIED
}

func (m *MsgRegisterDeviceKey) GetDeviceType() string {
	if m != nil {
		return m.DeviceType
	}
	return ""
}

func (m *MsgRegisterDeviceKey) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *MsgRegisterDeviceKey) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// MsgRegisterDeviceKeyResponse defines the response for RegisterDeviceKey
type MsgRegisterDeviceKeyResponse struct {
	// device_key is the registered device key information
	DeviceKey *DeviceKey `protobuf:"bytes,1,opt,name=device_key,json=deviceKey,proto3" json:"device_key,omitempty"`
}

func (m *MsgRegisterDeviceKeyResponse) Reset()         { *m = MsgRegisterDeviceKeyResponse{} }
func (m *MsgRegisterDeviceKeyResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterDeviceKeyResponse) ProtoMessage()    {}
func (*MsgRegisterDeviceKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{21}
}
func (m *MsgRegisterDeviceKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterDeviceKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterDeviceKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterDeviceKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterDeviceKeyResponse.Merge(m, src)
}
func (m *MsgRegisterDeviceKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterDeviceKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterDeviceKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterDeviceKeyResponse proto.InternalMessageInfo

func (m *MsgRegisterDeviceKeyResponse) GetDeviceKey() *DeviceKey {
	if m != nil {
		return m.DeviceKey
	}
	return nil
}

// MsgRevokeDeviceKey revokes a device's public key
type MsgRevokeDeviceKey struct {
	// owner is the address that owns the device
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// device_id is the unique identifier of the device
	DeviceId string `protobuf:"bytes,2,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	// revocation_reason describes why the key is revoked
	RevocationReason string `protobuf:"bytes,3,opt,name=revocation_reason,json=revocationReason,proto3" json:"revocation_reason,omitempty"`
}

func (m *MsgRevokeDeviceKey) Reset()         { *m = MsgRevokeDeviceKey{} }
func (m *MsgRevokeDeviceKey) String() string { return proto.CompactTextString(m) }
func (*MsgRevokeDeviceKey) ProtoMessage()    {}
func (*MsgRevokeDeviceKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{22}
}
func (m *MsgRevokeDeviceKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevokeDeviceKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevokeDeviceKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevokeDeviceKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevokeDeviceKey.Merge(m, src)
}
func (m *MsgRevokeDeviceKey) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevokeDeviceKey) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevokeDeviceKey.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevokeDeviceKey proto.InternalMessageInfo

func (m *MsgRevokeDeviceKey) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgRevokeDeviceKey) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *MsgRevokeDeviceKey) GetRevocationReason() string {
	if m != nil {
		return m.RevocationReason
	}
	return ""
}

// MsgRevokeDeviceKeyResponse defines the response for RevokeDeviceKey
type MsgRevokeDeviceKeyResponse struct {
}

func (m *MsgRevokeDeviceKeyResponse) Reset()         { *m = MsgRevokeDeviceKeyResponse{} }
func (m *MsgRevokeDeviceKeyResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRevokeDeviceKeyResponse) ProtoMessage()    {}
func (*MsgRevokeDeviceKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{23}
}
func (m *MsgRevokeDeviceKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevokeDeviceKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevokeDeviceKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevokeDeviceKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevokeDeviceKeyResponse.Merge(m, src)
}
func (m *MsgRevokeDeviceKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevokeDeviceKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevokeDeviceKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevokeDeviceKeyResponse proto.InternalMessageInfo

// MsgRotateDeviceKey rotates a device's public key
type MsgRotateDeviceKey struct {
	// owner is the address that owns the device
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// device_id is the unique identifier of the device
	DeviceId string `protobuf:"bytes,2,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	// new_public_key is the replacement public key
	NewPublicKey []byte `protobuf:"bytes,3,opt,name=new_public_key,json=newPublicKey,proto3" json:"new_public_key,omitempty"`
	// key_type is the cryptographic algorithm
	KeyType KeyType `protobuf:"varint,4,opt,name=key_type,json=keyType,proto3,enum=acmain.iam.v1.KeyType" json:"key_type,omitempty"`
}

func (m *MsgRotateDeviceKey) Reset()         { *m = MsgRotateDeviceKey{} }
func (m *MsgRotateDeviceKey) String() string { return proto.CompactTextString(m) }
func (*MsgRotateDeviceKey) ProtoMessage()    {}
func (*MsgRotateDeviceKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{24}
}
func (m *MsgRotateDeviceKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRotateDeviceKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRotateDeviceKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRotateDeviceKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRotateDeviceKey.Merge(m, src)
}
func (m *MsgRotateDeviceKey) XXX_Size() int {
	return m.Size()
}
func (m *MsgRotateDeviceKey) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRotateDeviceKey.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRotateDeviceKey proto.InternalMessageInfo

func (m *MsgRotateDeviceKey) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgRotateDeviceKey) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *MsgRotateDeviceKey) GetNewPublicKey() []byte {
	if m != nil {
		return m.NewPublicKey
	}
	return nil
}

func (m *MsgRotateDeviceKey) GetKeyType() KeyType {
	if m != nil {
		return m.KeyType
	}
	return KEY_TYPE_UNSPECIFIED
}

// MsgRotateDeviceKeyResponse defines the response for RotateDeviceKey
type MsgRotateDeviceKeyResponse struct {
	// device_key is the updated device key information
	DeviceKey *DeviceKey `protobuf:"bytes,1,opt,name=device_key,json=deviceKey,proto3" json:"device_key,omitempty"`
}

func (m *MsgRotateDeviceKeyResponse) Reset()         { *m = MsgRotateDeviceKeyResponse{} }
func (m *MsgRotateDeviceKeyResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRotateDeviceKeyResponse) ProtoMessage()    {}
func (*MsgRotateDeviceKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_270e62d65dfc0f50, []int{25}
}
func (m *MsgRotateDeviceKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRotateDeviceKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRotateDeviceKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRotateDeviceKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRotateDeviceKeyResponse.Merge(m, src)
}
func (m *MsgRotateDeviceKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRotateDeviceKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRotateDeviceKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRotateDeviceKeyResponse proto.InternalMessageInfo

func (m *MsgRotateDeviceKeyResponse) GetDeviceKey() *DeviceKey {
	if m != nil {
		return m.DeviceKey
	}
	return nil
}

func init() {
	proto.RegisterType((*MsgUpdateParams)(nil), "acmain.iam.v1.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "acmain.iam.v1.MsgUpdateParamsResponse")
	proto.RegisterType((*MsgRegisterDID)(nil), "acmain.iam.v1.MsgRegisterDID")
	proto.RegisterMapType((map[string]string)(nil), "acmain.iam.v1.MsgRegisterDID.MetadataEntry")
	proto.RegisterType((*MsgRegisterDIDResponse)(nil), "acmain.iam.v1.MsgRegisterDIDResponse")
	proto.RegisterType((*MsgUpdateDIDDocument)(nil), "acmain.iam.v1.MsgUpdateDIDDocument")
	proto.RegisterMapType((map[string]string)(nil), "acmain.iam.v1.MsgUpdateDIDDocument.MetadataEntry")
	proto.RegisterType((*MsgUpdateDIDDocumentResponse)(nil), "acmain.iam.v1.MsgUpdateDIDDocumentResponse")
	proto.RegisterType((*MsgDeactivateDID)(nil), "acmain.iam.v1.MsgDeactivateDID")
	proto.RegisterType((*MsgDeactivateDIDResponse)(nil), "acmain.iam.v1.MsgDeactivateDIDResponse")
	proto.RegisterType((*MsgAddPublicKey)(nil), "acmain.iam.v1.MsgAddPublicKey")
	proto.RegisterType((*MsgAddPublicKeyResponse)(nil), "acmain.iam.v1.MsgAddPublicKeyResponse")
	proto.RegisterType((*MsgRevokePublicKey)(nil), "acmain.iam.v1.MsgRevokePublicKey")
	proto.RegisterType((*MsgRevokePublicKeyResponse)(nil), "acmain.iam.v1.MsgRevokePublicKeyResponse")
	proto.RegisterType((*MsgIssueCredential)(nil), "acmain.iam.v1.MsgIssueCredential")
	proto.RegisterMapType((map[string]string)(nil), "acmain.iam.v1.MsgIssueCredential.ClaimsEntry")
	proto.RegisterMapType((map[string]string)(nil), "acmain.iam.v1.MsgIssueCredential.MetadataEntry")
	proto.RegisterType((*MsgIssueCredentialResponse)(nil), "acmain.iam.v1.MsgIssueCredentialResponse")
	proto.RegisterType((*MsgRevokeCredential)(nil), "acmain.iam.v1.MsgRevokeCredential")
	proto.RegisterType((*MsgRevokeCredentialResponse)(nil), "acmain.iam.v1.MsgRevokeCredentialResponse")
	proto.RegisterType((*MsgSuspendCredential)(nil), "acmain.iam.v1.MsgSuspendCredential")
	proto.RegisterType((*MsgSuspendCredentialResponse)(nil), "acmain.iam.v1.MsgSuspendCredentialResponse")
	proto.RegisterType((*MsgResumeCredential)(nil), "acmain.iam.v1.MsgResumeCredential")
	proto.RegisterType((*MsgResumeCredentialResponse)(nil), "acmain.iam.v1.MsgResumeCredentialResponse")
	proto.RegisterType((*MsgRegisterDeviceKey)(nil), "acmain.iam.v1.MsgRegisterDeviceKey")
	proto.RegisterMapType((map[string]string)(nil), "acmain.iam.v1.MsgRegisterDeviceKey.MetadataEntry")
	proto.RegisterType((*MsgRegisterDeviceKeyResponse)(nil), "acmain.iam.v1.MsgRegisterDeviceKeyResponse")
	proto.RegisterType((*MsgRevokeDeviceKey)(nil), "acmain.iam.v1.MsgRevokeDeviceKey")
	proto.RegisterType((*MsgRevokeDeviceKeyResponse)(nil), "acmain.iam.v1.MsgRevokeDeviceKeyResponse")
	proto.RegisterType((*MsgRotateDeviceKey)(nil), "acmain.iam.v1.MsgRotateDeviceKey")
	proto.RegisterType((*MsgRotateDeviceKeyResponse)(nil), "acmain.iam.v1.MsgRotateDeviceKeyResponse")
}

func init() { proto.RegisterFile("acmain/iam/v1/tx.proto", fileDescriptor_270e62d65dfc0f50) }

var fileDescriptor_270e62d65dfc0f50 = []byte{
	// 1652 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xcd, 0x6f, 0xdb, 0xc6,
	0x12, 0x37, 0x2d, 0x7f, 0x71, 0xe4, 0x4f, 0x3e, 0x27, 0x61, 0x18, 0x5b, 0x56, 0xe8, 0xbc, 0x17,
	0xc7, 0x7e, 0x91, 0x62, 0x07, 0xef, 0x35, 0x75, 0x51, 0x14, 0x76, 0x9c, 0x14, 0x86, 0x61, 0x20,
	0xa0, 0x13, 0xa7, 0x2d, 0x50, 0x08, 0xb4, 0xb8, 0x96, 0x59, 0x8b, 0x5c, 0x81, 0x4b, 0xc9, 0xd1,
	0xad, 0xe8, 0xb1, 0xa7, 0xb4, 0xc7, 0x16, 0x28, 0xd0, 0x5b, 0x0f, 0x3d, 0xf8, 0x90, 0x73, 0xcf,
	0x01, 0x8a, 0x02, 0x41, 0x4f, 0x3d, 0xb5, 0x45, 0x72, 0x30, 0x50, 0xa0, 0xff, 0x43, 0xc1, 0xdd,
	0x15, 0xc5, 0x8f, 0x95, 0xa5, 0x20, 0x76, 0x2e, 0x02, 0x77, 0xf6, 0xc7, 0x9d, 0x9d, 0x99, 0x9f,
	0x66, 0x7f, 0x4b, 0xb8, 0x68, 0x96, 0x1d, 0xd3, 0x76, 0x8b, 0xb6, 0xe9, 0x14, 0x1b, 0xcb, 0x45,
	0xff, 0x49, 0xa1, 0xe6, 0x61, 0x1f, 0x2b, 0x63, 0xcc, 0x5e, 0xb0, 0x4d, 0xa7, 0xd0, 0x58, 0xd6,
	0x72, 0x71, 0x98, 0x85, 0x1a, 0x76, 0x19, 0x95, 0x0e, 0x51, 0x93, 0xc1, 0xb5, 0x7c, 0x62, 0xde,
	0xb6, 0x4a, 0x16, 0x2e, 0xd7, 0x1d, 0xe4, 0xfa, 0x1c, 0x71, 0x39, 0x8e, 0x40, 0x6e, 0xdd, 0x21,
	0x7c, 0x4a, 0x8b, 0x4f, 0xd5, 0x4c, 0xcf, 0x0c, 0xe7, 0xe6, 0x13, 0x73, 0xf5, 0xbd, 0xaa, 0x5d,
	0x0e, 0x1c, 0x97, 0x6c, 0x77, 0x1f, 0x73, 0xd0, 0xb5, 0x38, 0x88, 0x20, 0x8f, 0x6e, 0x0f, 0xb9,
	0x56, 0x0d, 0xdb, 0xe1, 0x0e, 0x6e, 0xc4, 0x51, 0x0d, 0xe4, 0xd9, 0xfb, 0xb6, 0xb9, 0x57, 0x45,
	0xa5, 0xb2, 0x87, 0x2c, 0xe4, 0xfa, 0xb6, 0x59, 0xe5, 0xd0, 0x9b, 0x22, 0x68, 0xd9, 0xf4, 0x6d,
	0xec, 0x96, 0x3c, 0x54, 0xa5, 0x0f, 0xe4, 0xc0, 0xae, 0x71, 0xf8, 0x94, 0xe9, 0xd8, 0x2e, 0x2e,
	0xd2, 0x5f, 0x6e, 0xba, 0x54, 0xc6, 0xc4, 0xc1, 0xa4, 0xe8, 0x90, 0x4a, 0xb0, 0x82, 0x43, 0x2a,
	0xad, 0x3c, 0xb0, 0x89, 0x12, 0x1d, 0x15, 0xd9, 0x80, 0x4f, 0x4d, 0x57, 0x70, 0x05, 0x33, 0x7b,
	0xf0, 0xc4, 0xad, 0x73, 0x15, 0x8c, 0x2b, 0x55, 0x54, 0xa4, 0xa3, 0xbd, 0xfa, 0x7e, 0xd1, 0xb7,
	0x1d, 0x44, 0x7c, 0xd3, 0xe1, 0xde, 0xf5, 0x67, 0x12, 0x4c, 0x6c, 0x93, 0xca, 0xa3, 0x9a, 0x65,
	0xfa, 0xe8, 0x01, 0x4d, 0x9e, 0xf2, 0x7f, 0x90, 0xcd, 0xba, 0x7f, 0x80, 0x3d, 0xdb, 0x6f, 0xaa,
	0x52, 0x5e, 0x5a, 0x90, 0xd7, 0xd5, 0x5f, 0x9f, 0xdd, 0x9c, 0xe6, 0xfe, 0xd6, 0x2c, 0xcb, 0x43,
	0x84, 0xec, 0xf8, 0x9e, 0xed, 0x56, 0x8c, 0x36, 0x54, 0xb9, 0x03, 0x43, 0x2c, 0xfd, 0x6a, 0x7f,
	0x5e, 0x5a, 0xc8, 0xae, 0x5c, 0x28, 0xc4, 0x78, 0x50, 0x60, 0xcb, 0xaf, 0xcb, 0xcf, 0x7f, 0x9f,
	0xeb, 0xfb, 0xe1, 0xe4, 0x78, 0x51, 0x32, 0x38, 0x7e, 0xb5, 0xf8, 0xc5, 0xc9, 0xf1, 0x62, 0x7b,
	0xa5, 0x2f, 0x4f, 0x8e, 0x17, 0x67, 0x78, 0x16, 0x9f, 0xd0, 0x3c, 0x26, 0xb6, 0xa8, 0x5f, 0x86,
	0x4b, 0x09, 0x93, 0x81, 0x48, 0x0d, 0xbb, 0x04, 0xe9, 0xdf, 0x0c, 0xc0, 0xf8, 0x36, 0xa9, 0x18,
	0xa8, 0x62, 0x13, 0x1f, 0x79, 0x1b, 0x9b, 0x1b, 0xca, 0x1d, 0x80, 0x32, 0x76, 0x7d, 0x0f, 0x57,
	0xab, 0xc8, 0xeb, 0x1a, 0x51, 0x04, 0xab, 0x4c, 0x42, 0xc6, 0xb2, 0x2d, 0x1a, 0x8f, 0x6c, 0x04,
	0x8f, 0xca, 0x3b, 0x00, 0x01, 0x41, 0x1d, 0xe4, 0x1f, 0x60, 0x4b, 0xcd, 0xe4, 0xa5, 0x85, 0xf1,
	0x15, 0x35, 0x11, 0xe8, 0xc6, 0xe6, 0xc6, 0x36, 0x9d, 0x37, 0x64, 0xcb, 0xb6, 0xd8, 0xa3, 0x32,
	0x0b, 0xd0, 0x26, 0xa0, 0x3a, 0x90, 0x97, 0x16, 0x46, 0x0d, 0x99, 0x59, 0xb6, 0x50, 0x53, 0x59,
	0x86, 0x91, 0x80, 0x98, 0x7e, 0xb3, 0x86, 0xd4, 0x41, 0xba, 0xea, 0xc5, 0xc4, 0xaa, 0x5b, 0xa8,
	0xf9, 0xb0, 0x59, 0x43, 0xc6, 0xf0, 0x21, 0x7b, 0x50, 0x76, 0x61, 0x2a, 0xc9, 0x56, 0xa2, 0x0e,
	0xe5, 0x33, 0x0b, 0xd9, 0x95, 0x5c, 0xe2, 0xdd, 0x1d, 0x86, 0xbb, 0xc7, 0x61, 0xd1, 0x1a, 0x4c,
	0x92, 0xf8, 0x1c, 0x51, 0x74, 0x18, 0x33, 0xab, 0x04, 0x97, 0x0e, 0x5d, 0x7c, 0xe4, 0x96, 0x4c,
	0xa2, 0x0e, 0xe7, 0x33, 0x0b, 0xb2, 0x91, 0x0d, 0x8c, 0x5b, 0x81, 0x6d, 0x8d, 0x28, 0x1f, 0xc2,
	0x88, 0x83, 0x7c, 0xd3, 0x32, 0x7d, 0x53, 0x1d, 0xa1, 0x2e, 0x97, 0x12, 0x2e, 0xe3, 0x35, 0x28,
	0x6c, 0x73, 0xf4, 0x3d, 0xd7, 0xf7, 0x9a, 0x46, 0xf8, 0xb2, 0xf6, 0x1e, 0x8c, 0xc5, 0xa6, 0x82,
	0x94, 0x07, 0x09, 0x92, 0x58, 0xca, 0x0f, 0x51, 0x53, 0x99, 0x86, 0xc1, 0x86, 0x59, 0xad, 0x23,
	0x5e, 0x06, 0x36, 0x58, 0xed, 0xbf, 0x23, 0x31, 0xde, 0x44, 0xea, 0x15, 0x10, 0xe7, 0x4a, 0x92,
	0x38, 0x91, 0x5d, 0xe8, 0x8f, 0xe1, 0x62, 0xdc, 0xd2, 0xa2, 0x8d, 0xf2, 0x3e, 0x8c, 0x46, 0x1b,
	0x0f, 0xf5, 0x9f, 0x5d, 0xd1, 0xd2, 0x95, 0xdd, 0xe0, 0x08, 0x23, 0x6b, 0xd9, 0x56, 0x6b, 0xa0,
	0x7f, 0x9f, 0x81, 0xe9, 0x90, 0x91, 0x11, 0xd4, 0x99, 0x72, 0x4f, 0x58, 0xf0, 0xcc, 0x39, 0x14,
	0x7c, 0x20, 0x5d, 0xf0, 0xed, 0x48, 0xc1, 0x07, 0xa9, 0xcb, 0xe5, 0x74, 0xc1, 0x53, 0xe1, 0x9f,
	0x4f, 0xd9, 0xff, 0x27, 0x28, 0xfb, 0x55, 0x71, 0xbf, 0x88, 0xec, 0x45, 0xff, 0x14, 0x66, 0x44,
	0xf6, 0xb3, 0xa2, 0xc0, 0x57, 0x12, 0x4c, 0x6e, 0x93, 0xca, 0x06, 0x32, 0xcb, 0xbe, 0xdd, 0x60,
	0x3e, 0xce, 0xb2, 0xfc, 0xab, 0xcb, 0x82, 0xb0, 0x67, 0x93, 0x61, 0xc7, 0xdc, 0xeb, 0x1a, 0xa8,
	0x49, 0x5b, 0xd8, 0x28, 0xbf, 0xee, 0xa7, 0xad, 0x7f, 0xcd, 0xb2, 0x1e, 0x84, 0x5d, 0xe8, 0x2c,
	0xd9, 0x7a, 0x01, 0x86, 0xe8, 0x51, 0xcb, 0xba, 0xa4, 0x6c, 0x0c, 0x1e, 0xa2, 0xe6, 0xe6, 0x79,
	0xf4, 0x41, 0x15, 0x86, 0x6b, 0x75, 0xaf, 0x86, 0x09, 0x52, 0x87, 0xa8, 0xa7, 0xd6, 0x70, 0xf5,
	0x96, 0x20, 0x63, 0xa9, 0x83, 0x25, 0x9a, 0x00, 0xbd, 0x44, 0x0f, 0x96, 0xa8, 0x29, 0xa4, 0xc7,
	0x06, 0x4c, 0x24, 0x14, 0x04, 0x67, 0xc8, 0x4c, 0xf2, 0x9c, 0x6b, 0xbd, 0xba, 0xe9, 0xee, 0x63,
	0x63, 0xac, 0x16, 0x1d, 0xea, 0x3f, 0x4a, 0xa0, 0xd0, 0x16, 0xd4, 0xc0, 0x87, 0xe8, 0x6d, 0x26,
	0x7e, 0xf5, 0xb6, 0x20, 0x19, 0x73, 0xe9, 0x66, 0x19, 0xdb, 0x97, 0x3e, 0x03, 0x5a, 0xda, 0x1a,
	0x52, 0xe8, 0x78, 0x90, 0x06, 0xb3, 0x49, 0x48, 0x1d, 0xdd, 0x0d, 0x75, 0x90, 0x72, 0x0b, 0x86,
	0xec, 0xc0, 0xd4, 0x3d, 0x10, 0x8e, 0x0b, 0x4a, 0x48, 0xea, 0x7b, 0x9f, 0xa1, 0xb2, 0xcf, 0x03,
	0x69, 0x0d, 0x95, 0xfb, 0x30, 0xd1, 0x56, 0x58, 0x8c, 0x16, 0xec, 0xd0, 0x9d, 0x4d, 0x64, 0xbd,
	0xed, 0x9f, 0xb2, 0x63, 0xbc, 0x1c, 0x1b, 0x2b, 0xf7, 0x60, 0xa8, 0x5c, 0x35, 0x6d, 0x87, 0x35,
	0xb7, 0xec, 0xca, 0xcd, 0x74, 0xf7, 0x4a, 0x84, 0x51, 0xb8, 0x4b, 0xf1, 0xac, 0x73, 0xf1, 0x97,
	0x95, 0x0f, 0x00, 0x1a, 0x66, 0xd5, 0xb6, 0x4a, 0xfb, 0x1e, 0x76, 0x28, 0x41, 0x83, 0x0e, 0xc1,
	0x54, 0x56, 0xa1, 0xa5, 0xb2, 0x0a, 0x0f, 0x5b, 0x2a, 0x6b, 0x7d, 0xe0, 0xe9, 0x1f, 0x73, 0x92,
	0x21, 0xd3, 0x77, 0xee, 0x7b, 0xd8, 0x51, 0xd6, 0x20, 0xcb, 0x16, 0xa8, 0xbb, 0xbe, 0x5d, 0xa5,
	0x84, 0xed, 0x65, 0x05, 0xe6, 0xf5, 0x51, 0xf0, 0x8e, 0xb2, 0x15, 0x69, 0xc5, 0xc3, 0x34, 0x98,
	0x62, 0xf7, 0x60, 0x3a, 0x34, 0x62, 0xe5, 0x3a, 0x4c, 0x78, 0x68, 0xdf, 0x43, 0xe4, 0xa0, 0xc4,
	0xcf, 0x05, 0x75, 0x84, 0x56, 0x60, 0x9c, 0x9b, 0xf9, 0x49, 0xa2, 0xcc, 0x80, 0x4c, 0xec, 0x8a,
	0x6b, 0xfa, 0x75, 0x0f, 0xa9, 0x32, 0xfb, 0xdb, 0x86, 0x06, 0xed, 0x5d, 0xc8, 0x46, 0xd2, 0xf5,
	0x3a, 0xdd, 0xfc, 0x0c, 0x14, 0x00, 0x67, 0x91, 0x90, 0xd0, 0x89, 0x3c, 0xe8, 0xdf, 0x4a, 0x94,
	0xd1, 0x09, 0x73, 0xf8, 0x27, 0x9f, 0x87, 0xb1, 0x08, 0xdd, 0x6c, 0x8b, 0xef, 0x62, 0xb4, 0x6d,
	0xdc, 0xb4, 0x94, 0x8f, 0xe0, 0x82, 0xf0, 0x02, 0xc0, 0x75, 0xef, 0x7c, 0xa2, 0x1a, 0xbb, 0x21,
	0x36, 0xe2, 0x70, 0xba, 0x21, 0xb0, 0xea, 0x3f, 0x4b, 0xf0, 0xaf, 0xf0, 0xff, 0xf6, 0x46, 0xff,
	0xa8, 0x54, 0x20, 0xfd, 0x82, 0x40, 0x96, 0x60, 0xca, 0x43, 0x0d, 0x1c, 0x5e, 0x4e, 0x4c, 0x82,
	0x5d, 0xde, 0x34, 0x26, 0xdb, 0x13, 0x06, 0xb5, 0xb3, 0x66, 0x1a, 0x49, 0x75, 0x5e, 0xdc, 0x3b,
	0x22, 0xd1, 0xcc, 0xc2, 0x15, 0x81, 0x39, 0xec, 0x1e, 0xbf, 0x48, 0x54, 0x33, 0xed, 0xd4, 0x49,
	0x0d, 0xb9, 0xd6, 0x5b, 0x89, 0x96, 0x50, 0x5f, 0x24, 0x1d, 0x6d, 0x7b, 0x82, 0x47, 0xbb, 0x9c,
	0x88, 0x36, 0xa5, 0x2f, 0x52, 0xdb, 0xd6, 0x73, 0x54, 0x5f, 0xa4, 0xec, 0x61, 0xbc, 0xdf, 0xb5,
	0x8a, 0x4b, 0xea, 0xce, 0xf9, 0x17, 0xb7, 0x97, 0x7a, 0xc5, 0x37, 0x12, 0xd6, 0x2b, 0x6e, 0x6e,
	0x77, 0x7b, 0xa6, 0x71, 0x43, 0xf5, 0x4c, 0xef, 0xf1, 0xc1, 0xe1, 0x55, 0x80, 0x41, 0x7c, 0xe4,
	0xf6, 0xb0, 0x7f, 0x06, 0x53, 0xae, 0x80, 0xcc, 0x3f, 0x02, 0x84, 0x5b, 0x1f, 0x61, 0x86, 0x94,
	0x3e, 0xc8, 0x9c, 0xa6, 0x0f, 0x06, 0x7a, 0xd3, 0x07, 0x73, 0x90, 0xe5, 0xee, 0x42, 0x55, 0x21,
	0x1b, 0xc0, 0x4c, 0x14, 0xa0, 0xc1, 0x48, 0x95, 0x73, 0x9d, 0x2b, 0x88, 0x70, 0x1c, 0xd3, 0xbd,
	0xc3, 0x9d, 0x74, 0x6f, 0x2a, 0x25, 0xe7, 0xa3, 0x7b, 0x69, 0x45, 0x59, 0x0e, 0x85, 0x94, 0x4c,
	0x6d, 0x43, 0x7f, 0x4c, 0x29, 0x99, 0xb2, 0x87, 0xed, 0x2e, 0xb8, 0xcd, 0x86, 0x9f, 0x63, 0xb8,
	0x9c, 0x49, 0xdd, 0x66, 0xc3, 0xb7, 0x78, 0xd5, 0x82, 0x85, 0x7f, 0x8a, 0xca, 0x98, 0x73, 0x62,
	0xc2, 0x6b, 0x75, 0xa7, 0x42, 0x3c, 0x37, 0x1d, 0x84, 0x4d, 0x3b, 0x33, 0x51, 0x61, 0x93, 0xca,
	0x8b, 0xfe, 0x17, 0x0f, 0x0f, 0xfb, 0x81, 0x68, 0x3e, 0x9f, 0xf0, 0xae, 0xc1, 0xb8, 0x8b, 0x8e,
	0x4a, 0x29, 0xb2, 0x8f, 0xba, 0xe8, 0xe8, 0xc1, 0x1b, 0xf0, 0xbd, 0x7b, 0x2a, 0xe2, 0x51, 0xe9,
	0x8f, 0x58, 0x2a, 0xe2, 0xd6, 0x37, 0xa6, 0xc8, 0xca, 0xdf, 0x32, 0x64, 0xb6, 0x49, 0x45, 0xd9,
	0x85, 0xd1, 0xd8, 0xe7, 0xa5, 0x5c, 0xa7, 0x7b, 0x23, 0x9b, 0xd7, 0xfe, 0x73, 0xfa, 0x7c, 0xb8,
	0xb1, 0x1d, 0xc8, 0x46, 0x3f, 0xf2, 0xcc, 0x9e, 0xfa, 0xfd, 0x41, 0xfb, 0xf7, 0xa9, 0xd3, 0xe1,
	0xa2, 0x08, 0xa6, 0xd2, 0x77, 0xf8, 0xf9, 0x1e, 0x6e, 0xba, 0xda, 0x52, 0x0f, 0xa0, 0xd0, 0xcd,
	0xc7, 0x30, 0x16, 0xbf, 0x27, 0xce, 0xa5, 0xdf, 0x8e, 0x01, 0xb4, 0xeb, 0x5d, 0x00, 0xe1, 0xd2,
	0xbb, 0x30, 0x1a, 0xbb, 0xd2, 0x09, 0xd2, 0x1d, 0x9d, 0x17, 0xa5, 0x5b, 0x78, 0xfd, 0x29, 0xc1,
	0x44, 0xf2, 0xd2, 0x72, 0x55, 0x94, 0xd3, 0x18, 0x44, 0xbb, 0xd1, 0x15, 0x12, 0x75, 0x90, 0xbc,
	0x48, 0x5c, 0xed, 0xaa, 0x6b, 0x45, 0x0e, 0x3a, 0x69, 0xbb, 0x3d, 0x98, 0x4c, 0x09, 0x2b, 0xbd,
	0xd3, 0xfe, 0x22, 0x2e, 0x16, 0xbb, 0x63, 0xa2, 0xfc, 0x49, 0xeb, 0x19, 0x01, 0x7f, 0x52, 0x20,
	0x11, 0x7f, 0x3a, 0x4a, 0x09, 0x16, 0x4a, 0x42, 0x46, 0x08, 0x43, 0x89, 0x63, 0xc4, 0xa1, 0x88,
	0x8f, 0xfb, 0x20, 0x94, 0xf4, 0x51, 0x3f, 0xdf, 0xc3, 0xe1, 0xa7, 0x2d, 0xf5, 0x00, 0x4a, 0xf3,
	0xaa, 0xed, 0xa4, 0x23, 0xaf, 0xda, 0x2e, 0x6e, 0x74, 0x85, 0xc4, 0x1c, 0x24, 0xfa, 0xb8, 0xc8,
	0x41, 0x1c, 0x22, 0x74, 0x20, 0xee, 0x90, 0xda, 0xe0, 0xe7, 0x27, 0xc7, 0x8b, 0xd2, 0xfa, 0x7f,
	0x9f, 0xbf, 0xcc, 0x49, 0x2f, 0x5e, 0xe6, 0xa4, 0x3f, 0x5f, 0xe6, 0xa4, 0xa7, 0xaf, 0x72, 0x7d,
	0x2f, 0x5e, 0xe5, 0xfa, 0x7e, 0x7b, 0x95, 0xeb, 0xfb, 0x44, 0x89, 0x75, 0xe0, 0xa0, 0x95, 0x93,
	0xbd, 0x21, 0x7a, 0xd5, 0xbb, 0xfd, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x35, 0x76, 0x40, 0x86,
	0x44, 0x19, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	// RegisterDID registers a new Decentralized Identifier (DID) with its document
	RegisterDID(ctx context.Context, in *MsgRegisterDID, opts ...grpc.CallOption) (*MsgRegisterDIDResponse, error)
	// UpdateDIDDocument updates an existing DID document
	UpdateDIDDocument(ctx context.Context, in *MsgUpdateDIDDocument, opts ...grpc.CallOption) (*MsgUpdateDIDDocumentResponse, error)
	// DeactivateDID deactivates a DID, preventing further updates
	DeactivateDID(ctx context.Context, in *MsgDeactivateDID, opts ...grpc.CallOption) (*MsgDeactivateDIDResponse, error)
	// AddPublicKey adds a new public key to a DID document
	AddPublicKey(ctx context.Context, in *MsgAddPublicKey, opts ...grpc.CallOption) (*MsgAddPublicKeyResponse, error)
	// RevokePublicKey revokes a public key from a DID document
	RevokePublicKey(ctx context.Context, in *MsgRevokePublicKey, opts ...grpc.CallOption) (*MsgRevokePublicKeyResponse, error)
	// IssueCredential issues a new Verifiable Credential
	IssueCredential(ctx context.Context, in *MsgIssueCredential, opts ...grpc.CallOption) (*MsgIssueCredentialResponse, error)
	// RevokeCredential revokes a previously issued Verifiable Credential
	RevokeCredential(ctx context.Context, in *MsgRevokeCredential, opts ...grpc.CallOption) (*MsgRevokeCredentialResponse, error)
	// SuspendCredential suspends a Verifiable Credential (temporary revocation)
	SuspendCredential(ctx context.Context, in *MsgSuspendCredential, opts ...grpc.CallOption) (*MsgSuspendCredentialResponse, error)
	// ResumeCredential resumes a previously suspended Verifiable Credential
	ResumeCredential(ctx context.Context, in *MsgResumeCredential, opts ...grpc.CallOption) (*MsgResumeCredentialResponse, error)
	// RegisterDeviceKey registers a device's public key for IoT authentication
	RegisterDeviceKey(ctx context.Context, in *MsgRegisterDeviceKey, opts ...grpc.CallOption) (*MsgRegisterDeviceKeyResponse, error)
	// RevokeDeviceKey revokes a device's public key
	RevokeDeviceKey(ctx context.Context, in *MsgRevokeDeviceKey, opts ...grpc.CallOption) (*MsgRevokeDeviceKeyResponse, error)
	// RotateDeviceKey rotates a device's public key
	RotateDeviceKey(ctx context.Context, in *MsgRotateDeviceKey, opts ...grpc.CallOption) (*MsgRotateDeviceKeyResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RegisterDID(ctx context.Context, in *MsgRegisterDID, opts ...grpc.CallOption) (*MsgRegisterDIDResponse, error) {
	out := new(MsgRegisterDIDResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Msg/RegisterDID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateDIDDocument(ctx context.Context, in *MsgUpdateDIDDocument, opts ...grpc.CallOption) (*MsgUpdateDIDDocumentResponse, error) {
	out := new(MsgUpdateDIDDocumentResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Msg/UpdateDIDDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DeactivateDID(ctx context.Context, in *MsgDeactivateDID, opts ...grpc.CallOption) (*MsgDeactivateDIDResponse, error) {
	out := new(MsgDeactivateDIDResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Msg/DeactivateDID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddPublicKey(ctx context.Context, in *MsgAddPublicKey, opts ...grpc.CallOption) (*MsgAddPublicKeyResponse, error) {
	out := new(MsgAddPublicKeyResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Msg/AddPublicKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RevokePublicKey(ctx context.Context, in *MsgRevokePublicKey, opts ...grpc.CallOption) (*MsgRevokePublicKeyResponse, error) {
	out := new(MsgRevokePublicKeyResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Msg/RevokePublicKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) IssueCredential(ctx context.Context, in *MsgIssueCredential, opts ...grpc.CallOption) (*MsgIssueCredentialResponse, error) {
	out := new(MsgIssueCredentialResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Msg/IssueCredential", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RevokeCredential(ctx context.Context, in *MsgRevokeCredential, opts ...grpc.CallOption) (*MsgRevokeCredentialResponse, error) {
	out := new(MsgRevokeCredentialResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Msg/RevokeCredential", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SuspendCredential(ctx context.Context, in *MsgSuspendCredential, opts ...grpc.CallOption) (*MsgSuspendCredentialResponse, error) {
	out := new(MsgSuspendCredentialResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Msg/SuspendCredential", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ResumeCredential(ctx context.Context, in *MsgResumeCredential, opts ...grpc.CallOption) (*MsgResumeCredentialResponse, error) {
	out := new(MsgResumeCredentialResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Msg/ResumeCredential", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RegisterDeviceKey(ctx context.Context, in *MsgRegisterDeviceKey, opts ...grpc.CallOption) (*MsgRegisterDeviceKeyResponse, error) {
	out := new(MsgRegisterDeviceKeyResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Msg/RegisterDeviceKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RevokeDeviceKey(ctx context.Context, in *MsgRevokeDeviceKey, opts ...grpc.CallOption) (*MsgRevokeDeviceKeyResponse, error) {
	out := new(MsgRevokeDeviceKeyResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Msg/RevokeDeviceKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RotateDeviceKey(ctx context.Context, in *MsgRotateDeviceKey, opts ...grpc.CallOption) (*MsgRotateDeviceKeyResponse, error) {
	out := new(MsgRotateDeviceKeyResponse)
	err := c.cc.Invoke(ctx, "/acmain.iam.v1.Msg/RotateDeviceKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	// RegisterDID registers a new Decentralized Identifier (DID) with its document
	RegisterDID(context.Context, *MsgRegisterDID) (*MsgRegisterDIDResponse, error)
	// UpdateDIDDocument updates an existing DID document
	UpdateDIDDocument(context.Context, *MsgUpdateDIDDocument) (*MsgUpdateDIDDocumentResponse, error)
	// DeactivateDID deactivates a DID, preventing further updates
	DeactivateDID(context.Context, *MsgDeactivateDID) (*MsgDeactivateDIDResponse, error)
	// AddPublicKey adds a new public key to a DID document
	AddPublicKey(context.Context, *MsgAddPublicKey) (*MsgAddPublicKeyResponse, error)
	// RevokePublicKey revokes a public key from a DID document
	RevokePublicKey(context.Context, *MsgRevokePublicKey) (*MsgRevokePublicKeyResponse, error)
	// IssueCredential issues a new Verifiable Credential
	IssueCredential(context.Context, *MsgIssueCredential) (*MsgIssueCredentialResponse, error)
	// RevokeCredential revokes a previously issued Verifiable Credential
	RevokeCredential(context.Context, *MsgRevokeCredential) (*MsgRevokeCredentialResponse, error)
	// SuspendCredential suspends a Verifiable Credential (temporary revocation)
	SuspendCredential(context.Context, *MsgSuspendCredential) (*MsgSuspendCredentialResponse, error)
	// ResumeCredential resumes a previously suspended Verifiable Credential
	ResumeCredential(context.Context, *MsgResumeCredential) (*MsgResumeCredentialResponse, error)
	// RegisterDeviceKey registers a device's public key for IoT authentication
	RegisterDeviceKey(context.Context, *MsgRegisterDeviceKey) (*MsgRegisterDeviceKeyResponse, error)
	// RevokeDeviceKey revokes a device's public key
	RevokeDeviceKey(context.Context, *MsgRevokeDeviceKey) (*MsgRevokeDeviceKeyResponse, error)
	// RotateDeviceKey rotates a device's public key
	RotateDeviceKey(context.Context, *MsgRotateDeviceKey) (*MsgRotateDeviceKeyResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (*UnimplementedMsgServer) RegisterDID(ctx context.Context, req *MsgRegisterDID) (*MsgRegisterDIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterDID not implemented")
}
func (*UnimplementedMsgServer) UpdateDIDDocument(ctx context.Context, req *MsgUpdateDIDDocument) (*MsgUpdateDIDDocumentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDIDDocument not implemented")
}
func (*UnimplementedMsgServer) DeactivateDID(ctx context.Context, req *MsgDeactivateDID) (*MsgDeactivateDIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeactivateDID not implemented")
}
func (*UnimplementedMsgServer) AddPublicKey(ctx context.Context, req *MsgAddPublicKey) (*MsgAddPublicKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPublicKey not implemented")
}
func (*UnimplementedMsgServer) RevokePublicKey(ctx context.Context, req *MsgRevokePublicKey) (*MsgRevokePublicKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokePublicKey not implemented")
}
func (*UnimplementedMsgServer) IssueCredential(ctx context.Context, req *MsgIssueCredential) (*MsgIssueCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IssueCredential not implemented")
}
func (*UnimplementedMsgServer) RevokeCredential(ctx context.Context, req *MsgRevokeCredential) (*MsgRevokeCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeCredential not implemented")
}
func (*UnimplementedMsgServer) SuspendCredential(ctx context.Context, req *MsgSuspendCredential) (*MsgSuspendCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SuspendCredential not implemented")
}
func (*UnimplementedMsgServer) ResumeCredential(ctx context.Context, req *MsgResumeCredential) (*MsgResumeCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeCredential not implemented")
}
func (*UnimplementedMsgServer) RegisterDeviceKey(ctx context.Context, req *MsgRegisterDeviceKey) (*MsgRegisterDeviceKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterDeviceKey not implemented")
}
func (*UnimplementedMsgServer) RevokeDeviceKey(ctx context.Context, req *MsgRevokeDeviceKey) (*MsgRevokeDeviceKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeDeviceKey not implemented")
}
func (*UnimplementedMsgServer) RotateDeviceKey(ctx context.Context, req *MsgRotateDeviceKey) (*MsgRotateDeviceKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RotateDeviceKey not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RegisterDID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterDID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterDID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Msg/RegisterDID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterDID(ctx, req.(*MsgRegisterDID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateDIDDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateDIDDocument)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateDIDDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Msg/UpdateDIDDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateDIDDocument(ctx, req.(*MsgUpdateDIDDocument))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DeactivateDID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeactivateDID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DeactivateDID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Msg/DeactivateDID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DeactivateDID(ctx, req.(*MsgDeactivateDID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddPublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddPublicKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddPublicKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Msg/AddPublicKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddPublicKey(ctx, req.(*MsgAddPublicKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RevokePublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRevokePublicKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RevokePublicKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Msg/RevokePublicKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RevokePublicKey(ctx, req.(*MsgRevokePublicKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_IssueCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgIssueCredential)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).IssueCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Msg/IssueCredential",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).IssueCredential(ctx, req.(*MsgIssueCredential))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RevokeCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRevokeCredential)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RevokeCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Msg/RevokeCredential",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RevokeCredential(ctx, req.(*MsgRevokeCredential))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SuspendCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSuspendCredential)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SuspendCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Msg/SuspendCredential",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SuspendCredential(ctx, req.(*MsgSuspendCredential))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ResumeCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgResumeCredential)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ResumeCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Msg/ResumeCredential",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ResumeCredential(ctx, req.(*MsgResumeCredential))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RegisterDeviceKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterDeviceKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterDeviceKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Msg/RegisterDeviceKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterDeviceKey(ctx, req.(*MsgRegisterDeviceKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RevokeDeviceKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRevokeDeviceKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RevokeDeviceKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Msg/RevokeDeviceKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RevokeDeviceKey(ctx, req.(*MsgRevokeDeviceKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RotateDeviceKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRotateDeviceKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RotateDeviceKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acmain.iam.v1.Msg/RotateDeviceKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RotateDeviceKey(ctx, req.(*MsgRotateDeviceKey))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "acmain.iam.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "RegisterDID",
			Handler:    _Msg_RegisterDID_Handler,
		},
		{
			MethodName: "UpdateDIDDocument",
			Handler:    _Msg_UpdateDIDDocument_Handler,
		},
		{
			MethodName: "DeactivateDID",
			Handler:    _Msg_DeactivateDID_Handler,
		},
		{
			MethodName: "AddPublicKey",
			Handler:    _Msg_AddPublicKey_Handler,
		},
		{
			MethodName: "RevokePublicKey",
			Handler:    _Msg_RevokePublicKey_Handler,
		},
		{
			MethodName: "IssueCredential",
			Handler:    _Msg_IssueCredential_Handler,
		},
		{
			MethodName: "RevokeCredential",
			Handler:    _Msg_RevokeCredential_Handler,
		},
		{
			MethodName: "SuspendCredential",
			Handler:    _Msg_SuspendCredential_Handler,
		},
		{
			MethodName: "ResumeCredential",
			Handler:    _Msg_ResumeCredential_Handler,
		},
		{
			MethodName: "RegisterDeviceKey",
			Handler:    _Msg_RegisterDeviceKey_Handler,
		},
		{
			MethodName: "RevokeDeviceKey",
			Handler:    _Msg_RevokeDeviceKey_Handler,
		},
		{
			MethodName: "RotateDeviceKey",
			Handler:    _Msg_RotateDeviceKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "acmain/iam/v1/tx.proto",
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRegisterDID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterDID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterDID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTx(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTx(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTx(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.AlsoKnownAs) > 0 {
		for iNdEx := len(m.AlsoKnownAs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AlsoKnownAs[iNdEx])
			copy(dAtA[i:], m.AlsoKnownAs[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.AlsoKnownAs[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.ServiceEndpoints) > 0 {
		for iNdEx := len(m.ServiceEndpoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ServiceEndpoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.KeyType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.KeyType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.DidMethod != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.DidMethod))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Did) > 0 {
		i -= len(m.Did)
		copy(dAtA[i:], m.Did)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Did)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Controller) > 0 {
		i -= len(m.Controller)
		copy(dAtA[i:], m.Controller)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Controller)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterDIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterDIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterDIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DidDocument != nil {
		{
			size, err := m.DidDocument.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDIDDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDIDDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDIDDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTx(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTx(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTx(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.AlsoKnownAs) > 0 {
		for iNdEx := len(m.AlsoKnownAs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AlsoKnownAs[iNdEx])
			copy(dAtA[i:], m.AlsoKnownAs[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.AlsoKnownAs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ServiceEndpoints) > 0 {
		for iNdEx := len(m.ServiceEndpoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ServiceEndpoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Did) > 0 {
		i -= len(m.Did)
		copy(dAtA[i:], m.Did)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Did)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Controller) > 0 {
		i -= len(m.Controller)
		copy(dAtA[i:], m.Controller)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Controller)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDIDDocumentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDIDDocumentResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDIDDocumentResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DidDocument != nil {
		{
			size, err := m.DidDocument.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeactivateDID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeactivateDID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeactivateDID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Did) > 0 {
		i -= len(m.Did)
		copy(dAtA[i:], m.Did)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Did)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Controller) > 0 {
		i -= len(m.Controller)
		copy(dAtA[i:], m.Controller)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Controller)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeactivateDIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeactivateDIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeactivateDIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgAddPublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddPublicKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddPublicKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Purpose) > 0 {
		i -= len(m.Purpose)
		copy(dAtA[i:], m.Purpose)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Purpose)))
		i--
		dAtA[i] = 0x32
	}
	if m.KeyType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.KeyType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.KeyId) > 0 {
		i -= len(m.KeyId)
		copy(dAtA[i:], m.KeyId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.KeyId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Did) > 0 {
		i -= len(m.Did)
		copy(dAtA[i:], m.Did)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Did)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Controller) > 0 {
		i -= len(m.Controller)
		copy(dAtA[i:], m.Controller)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Controller)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddPublicKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddPublicKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddPublicKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PublicKeyInfo != nil {
		{
			size, err := m.PublicKeyInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRevokePublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevokePublicKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevokePublicKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KeyId) > 0 {
		i -= len(m.KeyId)
		copy(dAtA[i:], m.KeyId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.KeyId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Did) > 0 {
		i -= len(m.Did)
		copy(dAtA[i:], m.Did)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Did)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Controller) > 0 {
		i -= len(m.Controller)
		copy(dAtA[i:], m.Controller)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Controller)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRevokePublicKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevokePublicKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevokePublicKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgIssueCredential) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgIssueCredential) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgIssueCredential) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.RefreshService) > 0 {
		i -= len(m.RefreshService)
		copy(dAtA[i:], m.RefreshService)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RefreshService)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTx(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTx(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTx(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.ValidUntil != nil {
		n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.ValidUntil, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ValidUntil):])
		if err5 != nil {
			return 0, err5
		}
		i -= n5
		i = encodeVarintTx(dAtA, i, uint64(n5))
		i--
		dAtA[i] = 0x32
	}
	if m.ValidFrom != nil {
		n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.ValidFrom, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ValidFrom):])
		if err6 != nil {
			return 0, err6
		}
		i -= n6
		i = encodeVarintTx(dAtA, i, uint64(n6))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Claims) > 0 {
		for k := range m.Claims {
			v := m.Claims[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTx(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTx(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTx(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.CredentialType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.CredentialType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgIssueCredentialResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgIssueCredentialResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgIssueCredentialResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VerifiableCredential != nil {
		{
			size, err := m.VerifiableCredential.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.CredentialId) > 0 {
		i -= len(m.CredentialId)
		copy(dAtA[i:], m.CredentialId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CredentialId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRevokeCredential) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevokeCredential) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevokeCredential) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RevocationReason) > 0 {
		i -= len(m.RevocationReason)
		copy(dAtA[i:], m.RevocationReason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RevocationReason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CredentialId) > 0 {
		i -= len(m.CredentialId)
		copy(dAtA[i:], m.CredentialId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CredentialId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRevokeCredentialResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevokeCredentialResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevokeCredentialResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSuspendCredential) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSuspendCredential) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSuspendCredential) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SuspensionReason) > 0 {
		i -= len(m.SuspensionReason)
		copy(dAtA[i:], m.SuspensionReason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SuspensionReason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CredentialId) > 0 {
		i -= len(m.CredentialId)
		copy(dAtA[i:], m.CredentialId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CredentialId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSuspendCredentialResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSuspendCredentialResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSuspendCredentialResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgResumeCredential) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgResumeCredential) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgResumeCredential) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CredentialId) > 0 {
		i -= len(m.CredentialId)
		copy(dAtA[i:], m.CredentialId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CredentialId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgResumeCredentialResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgResumeCredentialResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgResumeCredentialResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRegisterDeviceKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterDeviceKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterDeviceKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTx(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTx(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTx(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DeviceType) > 0 {
		i -= len(m.DeviceType)
		copy(dAtA[i:], m.DeviceType)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DeviceType)))
		i--
		dAtA[i] = 0x2a
	}
	if m.KeyType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.KeyType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterDeviceKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterDeviceKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterDeviceKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeviceKey != nil {
		{
			size, err := m.DeviceKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRevokeDeviceKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevokeDeviceKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevokeDeviceKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RevocationReason) > 0 {
		i -= len(m.RevocationReason)
		copy(dAtA[i:], m.RevocationReason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RevocationReason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRevokeDeviceKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevokeDeviceKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevokeDeviceKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRotateDeviceKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRotateDeviceKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRotateDeviceKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.KeyType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.KeyType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.NewPublicKey) > 0 {
		i -= len(m.NewPublicKey)
		copy(dAtA[i:], m.NewPublicKey)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewPublicKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRotateDeviceKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRotateDeviceKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRotateDeviceKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeviceKey != nil {
		{
			size, err := m.DeviceKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRegisterDID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Controller)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Did)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DidMethod != 0 {
		n += 1 + sovTx(uint64(m.DidMethod))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.KeyType != 0 {
		n += 1 + sovTx(uint64(m.KeyType))
	}
	if len(m.ServiceEndpoints) > 0 {
		for _, e := range m.ServiceEndpoints {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.AlsoKnownAs) > 0 {
		for _, s := range m.AlsoKnownAs {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTx(uint64(len(k))) + 1 + len(v) + sovTx(uint64(len(v)))
			n += mapEntrySize + 1 + sovTx(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MsgRegisterDIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DidDocument != nil {
		l = m.DidDocument.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateDIDDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Controller)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Did)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.ServiceEndpoints) > 0 {
		for _, e := range m.ServiceEndpoints {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.AlsoKnownAs) > 0 {
		for _, s := range m.AlsoKnownAs {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTx(uint64(len(k))) + 1 + len(v) + sovTx(uint64(len(v)))
			n += mapEntrySize + 1 + sovTx(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MsgUpdateDIDDocumentResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DidDocument != nil {
		l = m.DidDocument.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDeactivateDID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Controller)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Did)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDeactivateDIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgAddPublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Controller)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Did)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.KeyId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.KeyType != 0 {
		n += 1 + sovTx(uint64(m.KeyType))
	}
	l = len(m.Purpose)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAddPublicKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublicKeyInfo != nil {
		l = m.PublicKeyInfo.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRevokePublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Controller)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Did)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.KeyId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRevokePublicKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgIssueCredential) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.CredentialType != 0 {
		n += 1 + sovTx(uint64(m.CredentialType))
	}
	if len(m.Claims) > 0 {
		for k, v := range m.Claims {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTx(uint64(len(k))) + 1 + len(v) + sovTx(uint64(len(v)))
			n += mapEntrySize + 1 + sovTx(uint64(mapEntrySize))
		}
	}
	if m.ValidFrom != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ValidFrom)
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ValidUntil != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ValidUntil)
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTx(uint64(len(k))) + 1 + len(v) + sovTx(uint64(len(v)))
			n += mapEntrySize + 1 + sovTx(uint64(mapEntrySize))
		}
	}
	l = len(m.RefreshService)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgIssueCredentialResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CredentialId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.VerifiableCredential != nil {
		l = m.VerifiableCredential.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRevokeCredential) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CredentialId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RevocationReason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRevokeCredentialResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSuspendCredential) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CredentialId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SuspensionReason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSuspendCredentialResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgResumeCredential) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CredentialId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgResumeCredentialResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRegisterDeviceKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.KeyType != 0 {
		n += 1 + sovTx(uint64(m.KeyType))
	}
	l = len(m.DeviceType)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTx(uint64(len(k))) + 1 + len(v) + sovTx(uint64(len(v)))
			n += mapEntrySize + 1 + sovTx(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MsgRegisterDeviceKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeviceKey != nil {
		l = m.DeviceKey.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRevokeDeviceKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RevocationReason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRevokeDeviceKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRotateDeviceKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewPublicKey)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.KeyType != 0 {
		n += 1 + sovTx(uint64(m.KeyType))
	}
	return n
}

func (m *MsgRotateDeviceKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeviceKey != nil {
		l = m.DeviceKey.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterDID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterDID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterDID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Did = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DidMethod", wireType)
			}
			m.DidMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DidMethod |= DIDMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= KeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceEndpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceEndpoints = append(m.ServiceEndpoints, ServiceEndpoint{})
			if err := m.ServiceEndpoints[len(m.ServiceEndpoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlsoKnownAs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlsoKnownAs = append(m.AlsoKnownAs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTx
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTx
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTx
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTx
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTx(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTx
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterDIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterDIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterDIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DidDocument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DidDocument == nil {
				m.DidDocument = &DIDDocument{}
			}
			if err := m.DidDocument.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDIDDocument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDIDDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDIDDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Did = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceEndpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceEndpoints = append(m.ServiceEndpoints, ServiceEndpoint{})
			if err := m.ServiceEndpoints[len(m.ServiceEndpoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlsoKnownAs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlsoKnownAs = append(m.AlsoKnownAs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTx
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTx
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTx
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTx
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTx(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTx
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDIDDocumentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDIDDocumentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDIDDocumentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DidDocument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DidDocument == nil {
				m.DidDocument = &DIDDocument{}
			}
			if err := m.DidDocument.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeactivateDID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeactivateDID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeactivateDID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Did = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeactivateDIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeactivateDIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeactivateDIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddPublicKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddPublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddPublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Did = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= KeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purpose", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Purpose = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddPublicKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddPublicKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddPublicKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicKeyInfo == nil {
				m.PublicKeyInfo = &PublicKeyInfo{}
			}
			if err := m.PublicKeyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevokePublicKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevokePublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevokePublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Did = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevokePublicKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevokePublicKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevokePublicKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgIssueCredential) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgIssueCredential: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgIssueCredential: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialType", wireType)
			}
			m.CredentialType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CredentialType |= CredentialType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Claims", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Claims == nil {
				m.Claims = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTx
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTx
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTx
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTx
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTx(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTx
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Claims[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidFrom == nil {
				m.ValidFrom = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.ValidFrom, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidUntil", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidUntil == nil {
				m.ValidUntil = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.ValidUntil, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTx
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTx
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTx
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTx
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTx(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTx
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshService = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgIssueCredentialResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgIssueCredentialResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgIssueCredentialResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifiableCredential", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VerifiableCredential == nil {
				m.VerifiableCredential = &VerifiableCredential{}
			}
			if err := m.VerifiableCredential.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevokeCredential) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevokeCredential: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevokeCredential: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevocationReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RevocationReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevokeCredentialResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevokeCredentialResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevokeCredentialResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSuspendCredential) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSuspendCredential: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSuspendCredential: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuspensionReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuspensionReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSuspendCredentialResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSuspendCredentialResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSuspendCredentialResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgResumeCredential) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgResumeCredential: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgResumeCredential: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgResumeCredentialResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgResumeCredentialResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgResumeCredentialResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterDeviceKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterDeviceKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterDeviceKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= KeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTx
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTx
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTx
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTx
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTx(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTx
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterDeviceKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterDeviceKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterDeviceKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceKey == nil {
				m.DeviceKey = &DeviceKey{}
			}
			if err := m.DeviceKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevokeDeviceKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevokeDeviceKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevokeDeviceKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevocationReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RevocationReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevokeDeviceKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevokeDeviceKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevokeDeviceKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRotateDeviceKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRotateDeviceKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRotateDeviceKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewPublicKey = append(m.NewPublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.NewPublicKey == nil {
				m.NewPublicKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= KeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRotateDeviceKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRotateDeviceKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRotateDeviceKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceKey == nil {
				m.DeviceKey = &DeviceKey{}
			}
			if err := m.DeviceKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
